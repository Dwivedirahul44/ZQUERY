<?xml version="1.0" encoding="utf-8"?>
<nugget name="ZQUERY">
 <PROG NAME="ZQUERY" VARCL="X" SUBC="1" APPL="W" SECU="ZPGN_001" RSTAT="T" RMAND="101" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Query Tcode" LENGTH="15 "/>
   </language>
  </textPool>
  <dynpros>
   <dynpro PROG="ZQUERY" DNUM="8000" FNUM="8000" BZMX="99 " BZBR="255 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="99 " NOCO="255 " VALP="0 " CUAN="G" SPRA="E" DTEXT="main Screen">
    <dynprofield FNAM="W_TABSTRIP" DIDX="0063" FLG1="08" FLG2="30" FLG3="00" FILL="I" FMB1="00" FMB2="00" LENG="FF" LINE="01" COLN="02" LTYP="J" LANF="65" LBLK="01" LREP="01" AGLT="06" ADEZ="0A"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB1" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="01" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="102" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB1"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB2" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="02" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="103" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB2"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB3" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="03" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="104" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB3"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB4" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="04" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="105" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB4"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB5" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="05" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="106" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB5"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB6" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="06" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="107" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB6"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB7" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="07" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="108" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB7"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB8" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="08" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="109" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB8"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB9" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="09" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="110" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB9"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB10" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0A" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="111" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB10"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB11" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0B" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="112" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB11"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB12" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0C" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="113" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB12"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB13" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0D" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="114" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB13"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB14" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0E" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="115" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB14"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB15" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0F" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="116" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB15"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB16" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="10" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="117" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB16"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB17" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="11" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="118" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB17"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB18" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="12" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="119" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB18"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB19" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="13" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="120" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB19"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB20" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="14" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="121" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB20"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB21" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="15" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="122" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB21"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB22" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="16" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="123" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB22"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB23" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="17" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="124" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB23"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB24" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="18" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="125" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB24"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB25" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="19" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="126" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB25"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB26" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1A" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="127" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB26"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB27" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1B" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="128" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB27"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB28" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1C" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="129" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB28"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB29" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1D" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="130" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB29"/>
    <dynprofield FNAM="W-TAB_TITLE-TAB30" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1E" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="131" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB30"/>
    <dynprofield FNAM="SUB" DIDX="0060" FLG1="00" FLG2="F0" FLG3="00" FILL="B" FMB1="30" FMB2="00" LENG="FD" LINE="03" COLN="03" LTYP="I" LANF="65" LBLK="00" LREP="00" AUTH="132" AGLT="03" ADEZ="03"/>
    <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE STATUS_8000.
  CALL SUBSCREEN SUB INCLUDING SY-REPID &apos;9000&apos;.

PROCESS AFTER INPUT.
  CALL SUBSCREEN SUB.
  module user_command_8000.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="9000" TYPE="I" FNUM="9000" BZMX="99 " BZBR="255 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="99 " NOCO="255 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Tabs subscreen">
    <dynprofield FNAM="CUSTCONT" DIDX="0063" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="FF" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="05" ADEZ="14"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
*  MODULE STATUS_0010.

PROCESS AFTER INPUT.
*MODULE STATUS_9000.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="9100" FNUM="9100" BZMX="17 " BZBR="135 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="22 " NOCO="139 " VALP="0 " CUAN="G" SPRA="E" DTEXT="QUery Gen">
    <dynprofield FNAM="SELECT" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="06" LINE="03" COLN="0C" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="select"/>
    <dynprofield FNAM="GET_FLD" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FILL="P" FMB1="30" FMB2="00" LENG="06" LINE="03" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" AGLT="00" ADEZ="00" STXT="Fields" RES1="                                                                                                                                                                        GET_FLD"/>
    <dynprofield FNAM="FROM" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="04" LINE="03" COLN="23" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="From" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="W-SEL_TABNAME" DIDX="0012" FLG1="81" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="03" COLN="2A" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
    <dynprofield FNAM="REFRESH" DIDX="0002" FLG1="00" FLG2="00" FLG3="00" FILL="P" FMB1="30" FMB2="00" LENG="04" LINE="03" COLN="3F" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00" STXT="@42@" RES1="                                                                                                                                                                        REF_INP"/>
    <dynprofield FNAM="TABLE_RALATIONS" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0F" LINE="03" COLN="59" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Table Relations"/>
    <dynprofield FNAM="CONT_SQLFIELDS" DIDX="000E" FLG1="00" FLG2="00" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="30" LINE="04" COLN="0C" LANF="00" LBLK="00" LREP="00" AUTH="103" AGLT="01" ADEZ="01"/>
    <dynprofield FNAM="CONT_TABREL" DIDX="000E" FLG1="00" FLG2="00" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="30" LINE="04" COLN="59" LANF="00" LBLK="00" LREP="00" AUTH="104" AGLT="01" ADEZ="01"/>
    <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE STATUS_9100.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_9100.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="9200" FNUM="9200" BZMX="28 " BZBR="132 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="28 " NOCO="132 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Settings">
    <dynprofield FNAM="CUSTCONT2" DIDX="001C" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="84" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="06"/>
    <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________" RES1="                                       00"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE STATUS_9200.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_9200.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="9300" TYPE="M" FNUM="9300" BZMX="4 " BZBR="52 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="4 " NOCO="58 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Save options">
    <dynprofield FNAM="W-QNAME_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="11" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Name of the query" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="W-QNAME" DIDX="0000" FLG1="80" FLG2="02" FLG3="A0" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
    <dynprofield FNAM="W-VISIBILITY_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0A" LINE="02" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Visibility" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="W-QVISIBILITY" DIDX="000F" FLG1="80" FLG2="00" FLG3="A8" FMB1="00" FMB2="00" LENG="01" LINE="02" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" RES1=" DL"/>
    <dynprofield FNAM="W-VIS_USERS_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="05" LINE="03" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Users"/>
    <dynprofield FNAM="W-VIS_USERS" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="0E" LINE="03" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________"/>
    <dynprofield FNAM="W-VUSER_SEL_MORE" DIDX="0003" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="30" FMB2="00" LENG="06" LINE="03" COLN="28" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" ITYP="C" AGLT="00" ADEZ="00" STXT="@00@__" RES1="                                                                                                                                                                        MSVUSER"/>
    <dynprofield FNAM="W-VISIBILITYGRP_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0A" LINE="04" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="User group" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="W-VISIBILITYGRP" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="08" LENG="0E" LINE="04" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" DMAC="USER_GROUP" ITYP="C" AGLT="00" ADEZ="00" STXT="______________"/>
    <dynprofield FNAM="W-UGROUP_SEL_MORE" DIDX="0003" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="30" FMB2="00" LENG="06" LINE="04" COLN="28" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="C" AGLT="00" ADEZ="00" STXT="@00@__" RES1="                                                                                                                                                                        MSUGROUP"/>
    <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE STATUS_9300.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_9300 at EXIT-COMMAND.
 MODULE USER_COMMAND_9300.</dynproflowsource>
   </dynpro>
  </dynpros>
  <pfstatus>
   <pfstatus_sta CODE="PF_9000" MODAL="D" ACTCODE="000004" PFKCODE="000001" BUTCODE="0001" INT_NOTE="Main status"/>
   <pfstatus_sta CODE="PF_9100" MODAL="P" PFKCODE="000004" BUTCODE="0001" INT_NOTE="Query Wizard"/>
   <pfstatus_sta CODE="PF_9200" MODAL="P" PFKCODE="000003" BUTCODE="0001" INT_NOTE="Settings"/>
   <pfstatus_sta CODE="STATUS9300" MODAL="P" PFKCODE="000005" BUTCODE="0001" INT_NOTE="Save Option"/>
   <pfstatus_fun CODE="CANCEL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="EXIT_Q"/>
   <pfstatus_fun CODE="CHECK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CHECK" ICON_ID="@38@" FUN_TEXT="Check" INFO_TEXT="Check Query"/>
   <pfstatus_fun CODE="CLOSE" TEXTNO="001" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Interrupt"/>
   <pfstatus_fun CODE="CLOSE_QWIZ" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
   <pfstatus_fun CODE="CLOSE_SET" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Close"/>
   <pfstatus_fun CODE="COLLAPSE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_VIEW_EXPAND_HORIZONTAL" ICON_ID="@UM@" FUN_TEXT="COL/EXP"/>
   <pfstatus_fun CODE="DEL_TAB" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_REMOVE_ROW" ICON_ID="@XQ@" FUN_TEXT="DEL_TAB"/>
   <pfstatus_fun CODE="DOWNLOAD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Execute into file" ICON_TEXT="Execute into file"/>
   <pfstatus_fun CODE="EXEC2BG" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYM_SPOOL_SERVER" ICON_ID="@G7@" FUN_TEXT="Execute to App Server" ICON_TEXT="Execute as a Background Job"/>
   <pfstatus_fun CODE="EXEC2PC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_WRITE_FILE" ICON_ID="@HK@" FUN_TEXT="Execute to PC" ICON_TEXT="Execute to file"/>
   <pfstatus_fun CODE="EXECUTE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Execute" ICON_TEXT="Execute"/>
   <pfstatus_fun CODE="EXIT" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Back"/>
   <pfstatus_fun CODE="EXIT" TEXTNO="002" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
   <pfstatus_fun CODE="EXIT" TEXTNO="003" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
   <pfstatus_fun CODE="EXP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_VIEW_EXPAND_HORIZONTAL" ICON_ID="@UM@" FUN_TEXT="COL/EXP"/>
   <pfstatus_fun CODE="GET_FLD" TEXTNO="001" TEXT_TYPE="S" ICON_ID="@0V@" FUN_TEXT="Close"/>
   <pfstatus_fun CODE="HELP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Help" ICON_TEXT="Help"/>
   <pfstatus_fun CODE="MAX_ROW" TEXTNO="001" TEXT_TYPE="D" TEXT_NAME="W-MAX_ROW"/>
   <pfstatus_fun CODE="NEW" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ADD_ROW" ICON_ID="@XR@" FUN_TEXT="NEW" INFO_TEXT="New Tab"/>
   <pfstatus_fun CODE="OK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="GEN_QUERY"/>
   <pfstatus_fun CODE="OK" TEXTNO="002" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Continue"/>
   <pfstatus_fun CODE="OK_QWIZ" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Close"/>
   <pfstatus_fun CODE="OK_SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Continue"/>
   <pfstatus_fun CODE="OK_SET" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Continue"/>
   <pfstatus_fun CODE="OPTIONS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOOLS" ICON_ID="@45@" FUN_TEXT="Options" ICON_TEXT="Options"/>
   <pfstatus_fun CODE="QWIZ" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_WIZARD" ICON_ID="@BY@" FUN_TEXT="Query Wizard" ICON_TEXT="Query Wizard"/>
   <pfstatus_fun CODE="SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
   <pfstatus_fun CODE="SETTINGS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SETTINGS" ICON_ID="@XC@" FUN_TEXT="Settings" ICON_TEXT="Settings"/>
   <pfstatus_fun CODE="SHOWCODE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ABAP" ICON_ID="@9U@" FUN_TEXT="Display generated program" ICON_TEXT="Generated program"/>
   <pfstatus_fun CODE="XML" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Export XML" ICON_TEXT="Export Saved Queries"/>
   <pfstatus_fun CODE="XMLI" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_IMPORT" ICON_ID="@48@" FUN_TEXT="Import XML" ICON_TEXT="Import Queries"/>
   <pfstatus_mtx CODE="000001" TEXT_TYPE="S" TEXT="&lt;Object&gt;" PATH="O" INT_NOTE="Standard Supplement"/>
   <pfstatus_mtx CODE="000002" TEXT_TYPE="S" TEXT="Edit" PATH="E" INT_NOTE="Standard Supplement"/>
   <pfstatus_mtx CODE="000003" TEXT_TYPE="S" TEXT="Goto" PATH="G" INT_NOTE="Standard Supplement"/>
   <pfstatus_mtx CODE="000004" TEXT_TYPE="S" TEXT="Extras" PATH="A" INT_NOTE="Standard Supplement"/>
   <pfstatus_mtx CODE="000005" TEXT_TYPE="S" TEXT="Environment" PATH="V" INT_NOTE="Standard Supplement"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="05"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="25"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="03" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="04" PFNO="17"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="05" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="06" PFNO="14"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="07" PFNO="08"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="08" PFNO="18"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="09" PFNO="09"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="10" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="11" PFNO="48"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="12" PFNO="47"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="13" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="14" PFNO="37"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="02" PFNO="39"/>
   <pfstatus_but PFK_CODE="000003" CODE="0001" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000003" CODE="0001" NO="02" PFNO="25"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="01" PFNO="44"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="02" PFNO="39"/>
   <pfstatus_but PFK_CODE="000005" CODE="0001" NO="01" PFNO="05"/>
   <pfstatus_but PFK_CODE="000005" CODE="0001" NO="02" PFNO="12"/>
   <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="EXIT" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="05" FUNCODE="NEW" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="06" FUNCODE="SHOWCODE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="08" FUNCODE="EXECUTE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="09" FUNCODE="EXEC2BG" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="11" FUNCODE="SAVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="EXIT" FUNNO="002"/>
   <pfstatus_pfk CODE="000001" PFNO="14" FUNCODE="CHECK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="EXIT" FUNNO="003"/>
   <pfstatus_pfk CODE="000001" PFNO="17" FUNCODE="QWIZ" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="18" FUNCODE="EXEC2PC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="25" FUNCODE="DEL_TAB" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="29" FUNCODE="COLLAPSE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="37" FUNCODE="MAX_ROW" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="47" FUNCODE="EXP" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="48" FUNCODE="SETTINGS" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="08" FUNCODE="OK" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="39" FUNCODE="CANCEL" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="00" FUNCODE="OK_SET" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="25" FUNCODE="CLOSE_SET" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="39" FUNCODE="CLOSE_QWIZ" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="44" FUNCODE="OK_QWIZ" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="00" FUNCODE="GET_FLD" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="12" FUNCODE="CLOSE_QWIZ" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="25" FUNCODE="CLOSE_SET" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="39" FUNCODE="CLOSE_QWIZ" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="44" FUNCODE="OK_QWIZ" FUNNO="001"/>
   <pfstatus_pfk CODE="000005" PFNO="00" FUNCODE="OK" FUNNO="002"/>
   <pfstatus_pfk CODE="000005" PFNO="05" FUNCODE="OK_SAVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000005" PFNO="12" FUNCODE="CLOSE" FUNNO="001"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="CHECK"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="COLLAPSE"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="DEL_TAB"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="EXEC2BG"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="EXEC2PC"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="EXECUTE"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="EXIT"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="EXP"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="MAX_ROW"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="NEW"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="QWIZ"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="SAVE"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="SETTINGS"/>
   <pfstatus_set STATUS="PF_9000" FUNCTION="SHOWCODE"/>
   <pfstatus_set STATUS="PF_9100" FUNCTION="CLOSE_QWIZ"/>
   <pfstatus_set STATUS="PF_9100" FUNCTION="CLOSE_SET"/>
   <pfstatus_set STATUS="PF_9100" FUNCTION="GET_FLD"/>
   <pfstatus_set STATUS="PF_9100" FUNCTION="OK_QWIZ"/>
   <pfstatus_set STATUS="PF_9100" FUNCTION="OK_SET"/>
   <pfstatus_set STATUS="PF_9200" FUNCTION="CLOSE_SET"/>
   <pfstatus_set STATUS="PF_9200" FUNCTION="OK_SET"/>
   <pfstatus_set STATUS="STATUS9300" FUNCTION="CLOSE"/>
   <pfstatus_set STATUS="STATUS9300" FUNCTION="OK"/>
   <pfstatus_set STATUS="STATUS9300" FUNCTION="OK_SAVE"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="Main status"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="Main status"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" INT_NOTE="Main status"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000002" MODAL="P" INT_NOTE="SEl scr sta"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000002" SUB_CODE="0001" MODAL="P" INT_NOTE="SEl scr sta"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000003" MODAL="P" INT_NOTE="Settings"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000003" SUB_CODE="0001" MODAL="P" INT_NOTE="Settings"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000004" MODAL="P" INT_NOTE="Query Wizard"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000004" SUB_CODE="0001" MODAL="P" INT_NOTE="Query Wizard"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000002" MODAL="D" INT_NOTE="Main status"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000005" MODAL="P" INT_NOTE="Save Option"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000005" SUB_CODE="0001" MODAL="P" INT_NOTE="Save Option"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000003" MODAL="D" INT_NOTE="Main status"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000004" MODAL="D" INT_NOTE="Main status"/>
  </pfstatus>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZRD_QUERY
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT  zquery    NO STANDARD PAGE HEADING.

INCLUDE ZQUERY_TOP.

INCLUDE ZQUERY_APP.

INCLUDE ZQUERY_SCR.

INCLUDE ZQUERY_MAIN.


INITIALIZATION.

  lcl_main=&gt;handle_initialization( ).


START-OF-SELECTION.

  lcl_main=&gt;o_self-&gt;handle_start( iv_query = p_query
                                  iv_upto  = p_upto ).

*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_0010  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_8000 OUTPUT.

  lcl_main=&gt;o_self-&gt;handle_pbo( syst-dynnr ).


ENDMODULE.                 &quot; STATUS_0010  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_9000  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_8000 INPUT.

  lcl_main=&gt;o_self-&gt;handle_pai( w_okcode ).

  CLEAR w_okcode.

ENDMODULE.                 &quot; STATUS_9000  INPUT


*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_9100  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_9100 OUTPUT.

  SET PF-STATUS &apos;PF_9100&apos;.
  lcl_main=&gt;o_self-&gt;handle_pbo( syst-dynnr ).

ENDMODULE.                 &quot; STATUS_9100  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_9100  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_9100 INPUT.

  lcl_main=&gt;o_self-&gt;handle_pai( w_okcode ).
  CLEAR w_okcode.

ENDMODULE.                 &quot; USER_COMMAND_9100  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_9200  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_9200 OUTPUT.
  SET PF-STATUS &apos;PF_9200&apos;.
*  SET TITLEBAR &apos;xxx&apos;.
    lcl_main=&gt;o_self-&gt;handle_pbo( syst-dynnr ).
ENDMODULE.                 &quot; STATUS_9200  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_9200  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_9200 INPUT.
  lcl_main=&gt;o_self-&gt;handle_pai( w_okcode ).
  CLEAR w_okcode.
ENDMODULE.                 &quot; USER_COMMAND_9200  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_9300  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_9300 OUTPUT.
  SET PF-STATUS &apos;STATUS9300&apos;.
*  SET TITLEBAR &apos;xxx&apos;.
    lcl_main=&gt;o_self-&gt;handle_pbo( syst-dynnr ).
ENDMODULE.                 &quot; STATUS_9300  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_9300  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_9300 INPUT.
  lcl_main=&gt;o_self-&gt;handle_pai( w_okcode ).
  CLEAR w_okcode.
ENDMODULE.                 &quot; USER_COMMAND_9300  INPUT</source>
 </PROG>
 <PROG NAME="ZQUERY_TOP" VARCL="X" SUBC="I" SECU="&amp;NBSP" LEVL="702" RSTAT="T" RMAND="101" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZRD_QUERY_TOP" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*INCLUDE rsxplora.


CONSTANTS :
  BEGIN OF c,
    X                    type char1  value &apos;X&apos;     ,
  END OF c.

TYPES:
  BEGIN OF ty_header,
    heading(600)         TYPE c,
  END OF ty_header,
  BEGIN OF ty_qrep_node.
    INCLUDE TYPE treev_node. &quot;mtreesnode.
    types:
      text(100)          TYPE c,
      edit(1)            TYPE c,
      queryid            TYPE GUID_32,
  END OF ty_qrep_node,

tty_header               TYPE STANDARD TABLE OF ty_header   ,
tty_qrep_node            TYPE STANDARD TABLE OF ty_qrep_node.

DATA w_okcode            TYPE okcode.
CONTROLS w_tabstrip      TYPE TABSTRIP.

CLASS:
  lcl_scr                DEFINITION DEFERRED,
  lcl_app                DEFINITION DEFERRED.

DATA:
BEGIN OF w,

  BEGIN OF tab_title,
    tab1                 TYPE string VALUE &apos;Tab 1&apos;,                  &quot;#EC NOTEXT
    tab2                 TYPE string VALUE &apos;Tab 2&apos;,                  &quot;#EC NOTEXT
    tab3                 TYPE string VALUE &apos;Tab 3&apos;,                  &quot;#EC NOTEXT
    tab4                 TYPE string VALUE &apos;Tab 4&apos;,                  &quot;#EC NOTEXT
    tab5                 TYPE string VALUE &apos;Tab 5&apos;,                  &quot;#EC NOTEXT
    tab6                 TYPE string VALUE &apos;Tab 6&apos;,                  &quot;#EC NOTEXT
    tab7                 TYPE string VALUE &apos;Tab 7&apos;,                  &quot;#EC NOTEXT
    tab8                 TYPE string VALUE &apos;Tab 8&apos;,                  &quot;#EC NOTEXT
    tab9                 TYPE string VALUE &apos;Tab 9&apos;,                  &quot;#EC NOTEXT
    tab10                TYPE string VALUE &apos;Tab 10&apos;,                 &quot;#EC NOTEXT
    tab11                TYPE string VALUE &apos;Tab 11&apos;,                 &quot;#EC NOTEXT
    tab12                TYPE string VALUE &apos;Tab 12&apos;,                 &quot;#EC NOTEXT
    tab13                TYPE string VALUE &apos;Tab 13&apos;,                 &quot;#EC NOTEXT
    tab14                TYPE string VALUE &apos;Tab 14&apos;,                 &quot;#EC NOTEXT
    tab15                TYPE string VALUE &apos;Tab 15&apos;,                 &quot;#EC NOTEXT
    tab16                TYPE string VALUE &apos;Tab 16&apos;,                 &quot;#EC NOTEXT
    tab17                TYPE string VALUE &apos;Tab 17&apos;,                 &quot;#EC NOTEXT
    tab18                TYPE string VALUE &apos;Tab 18&apos;,                 &quot;#EC NOTEXT
    tab19                TYPE string VALUE &apos;Tab 19&apos;,                 &quot;#EC NOTEXT
    tab20                TYPE string VALUE &apos;Tab 20&apos;,                 &quot;#EC NOTEXT
    tab21                TYPE string VALUE &apos;Tab 21&apos;,                 &quot;#EC NOTEXT
    tab22                TYPE string VALUE &apos;Tab 22&apos;,                 &quot;#EC NOTEXT
    tab23                TYPE string VALUE &apos;Tab 23&apos;,                 &quot;#EC NOTEXT
    tab24                TYPE string VALUE &apos;Tab 24&apos;,                 &quot;#EC NOTEXT
    tab25                TYPE string VALUE &apos;Tab 25&apos;,                 &quot;#EC NOTEXT
    tab26                TYPE string VALUE &apos;Tab 26&apos;,                 &quot;#EC NOTEXT
    tab27                TYPE string VALUE &apos;Tab 27&apos;,                 &quot;#EC NOTEXT
    tab28                TYPE string VALUE &apos;Tab 28&apos;,                 &quot;#EC NOTEXT
    tab29                TYPE string VALUE &apos;Tab 29&apos;,                 &quot;#EC NOTEXT
    tab30                TYPE string VALUE &apos;Tab 30&apos;,                 &quot;#EC NOTEXT
  END OF tab_title,
    max_row                TYPE SMP_DYNTXT,
    qvisibility            TYPE char1,
    visibilitygrp          TYPE xuclass,
    vis_users              TYPE syuname,
    vuser_sel_more         TYPE char20,
    UGROUP_SEL_MORE        TYPE char20,
    qname                  TYPE char30,
    o_container_options    TYPE REF TO cl_gui_custom_container,
    o_splitter_ddic_full   TYPE REF TO cl_rsawb_splitter_for_toolbar,
    o_container_ddic       TYPE REF TO cl_gui_container,
    o_toolbar              TYPE REF TO cl_gui_toolbar,
    o_container            TYPE REF TO cl_gui_custom_container,
    o_splitter             TYPE REF TO cl_gui_splitter_container,
    o_container_ddic_full  TYPE REF TO cl_gui_container,
    o_container_qrep       TYPE REF TO cl_gui_container,
    o_qcontainer           TYPE REF TO cl_gui_container,
    o_sqlfld_cont          TYPE REF TO cl_gui_custom_container,
    o_tabrel_cont          TYPE REF TO cl_gui_custom_container,
    o_sqlfld_alv           TYPE REF TO cl_gui_alv_grid,
    o_tabrel_alv           TYPE REF TO cl_gui_alv_grid,
    sel_tabname            TYPE tabname,
    s1                     TYPE string,


END OF w.


  PARAMETERS: p_query TYPE string NO-DISPLAY.
  PARAMETERS: p_upto TYPE i NO-DISPLAY .</source>
 </PROG>
 <PROG NAME="ZQUERY_APP" VARCL="X" SUBC="I" SECU="&amp;NBSP" LEVL="702" RSTAT="T" RMAND="101" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZRD_QUERY_APP" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
*       CLASS lcl_error DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_error DEFINITION INHERITING FROM cx_static_check FINAL.
  PUBLIC SECTION.
    DATA: v_text     TYPE string READ-ONLY.

    METHODS:
      constructor      IMPORTING iv_text         TYPE string OPTIONAL .                                                               &quot;2
ENDCLASS.                    &quot;lcl_error DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_error IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_error IMPLEMENTATION .

  METHOD constructor.

    super-&gt;constructor( ).

    v_text = iv_text.

  ENDMETHOD.                    &quot;constructor

ENDCLASS.                    &quot;lcl_error IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcl_app DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_app DEFINITION FINAL.

  PUBLIC SECTION.

    TYPES :
      BEGIN OF ty_dd03vt,
        tabname              TYPE tabname, &quot; Table Name
        fieldname            TYPE fieldname, &quot; Field Name
        position             TYPE tabfdpos, &quot; Position of the field in the table
        rollname             TYPE rollname,
        checktable           TYPE checktable, &quot; check table
        ddtext               TYPE as4text, &quot; Short Description of Repository Objects
      END OF ty_dd03vt,
      BEGIN OF ty_sqlfields,
        tabname              TYPE tabname,
        fieldname            TYPE fieldname,
        ddtext               TYPE as4text,
        input                TYPE abap_bool,
      END OF ty_sqlfields,
      BEGIN OF ty_tabrel,
        tabname1             TYPE tabname,
        rel_txt              TYPE char30,
        tabname2             TYPE tabname,
      END OF ty_tabrel,
      BEGIN OF ty_ddic_fields,
        tabname              TYPE dd03l-tabname,
        fieldname            TYPE dd03l-fieldname,
        position             TYPE dd03l-position,
        keyflag              TYPE dd03l-keyflag,
        ddtext1              TYPE char40,
      END OF ty_ddic_fields,
      BEGIN OF ty_joinfld,
        tab1                 TYPE tabname,
        fldname              TYPE fieldname,
        tab2                 TYPE tabname,
        position             TYPE tabfdpos,
        key                  TYPE keyflag,
        key2                 TYPE keyflag,
      END OF ty_joinfld,
      BEGIN OF ty_list,
        ref                        TYPE REF TO lcl_scr,
      END OF ty_list,
      BEGIN OF ty_tabfield,
        tabname  TYPE tabname,
        fieldname TYPE fieldname,
      END OF ty_tabfield    ,
      tty_joinfld              TYPE STANDARD TABLE OF ty_joinfld     WITH DEFAULT KEY,
      tty_ddic_fields          TYPE STANDARD TABLE OF ty_ddic_fields WITH DEFAULT KEY,
      tty_fields               TYPE STANDARD TABLE OF ty_sqlfields   WITH DEFAULT KEY,
      tty_sqlfld               TYPE STANDARD TABLE OF ty_sqlfields   WITH DEFAULT KEY,
      tty_tabrel               TYPE STANDARD TABLE OF ty_tabrel      WITH DEFAULT KEY,
      tty_dd03vt     TYPE STANDARD TABLE OF ty_dd03vt WITH DEFAULT KEY,
      tty_tabfield   TYPE STANDARD TABLE OF ty_tabfield WITH DEFAULT KEY.

    CLASS-DATA:
      t_list                       TYPE STANDARD TABLE OF ty_list    READ-ONLY,
      t_sqlfld                     TYPE STANDARD TABLE OF ty_sqlfields,
      t_tabrel                     TYPE STANDARD TABLE OF ty_tabrel,
      paste_break                  TYPE abap_bool,
      techname                     TYPE abap_bool,
      conversion                   TYPE abap_bool,
      default_rows                 TYPE i                      VALUE 100.
*      rt_ugroup                    TYPE RANGE OF xuclass,
*      rt_users                     TYPE TRGR_USER_NAME.

    CLASS-METHODS:

*      init              RETURNING value(rv_allok)                    TYPE abap_bool,

      str_2_range             IMPORTING iv_str                       TYPE string
                        RETURNING value(rt_rnge)                     TYPE rsis_t_range,

      save_query              IMPORTING iv_query                     TYPE string
                               CHANGING cs_ztquery                   TYPE ztquery OPTIONAL,

      call_multisel           IMPORTING iv_excl_opt                  TYPE rsoptions
                                        iv_input                     TYPE rstabfield
                                        iv_hlpname                   TYPE shlpname OPTIONAL
                               CHANGING ct_rettab                    TYPE STANDARD TABLE,

*      hndl_vuser_multi,

      rfrsh_qwiz_data,

      popup_get_values  EXPORTING value(ev_exit)                     TYPE abap_bool
                               CHANGING cs_sval                      TYPE sval ,

      ret_ora_whr_str         IMPORTING iv_whr                       TYPE string
                                        iv_upto                      TYPE i
                        RETURNING value(rv_whr_str)                  TYPE string,

      call_sel_screen         EXPORTING et_where                     TYPE rsds_twhere
                               CHANGING ct_fld                       TYPE rsdsfields_t,

      ret_query         RETURNING value(rt_string)                   TYPE string_table ,

      handle_sqlfld           IMPORTING iv_tabname                   TYPE tabname
                                RAISING lcl_error,

      chk_tabnm_empt_vald    IMPORTING iv_tabname                    TYPE tabname
                               RAISING lcl_error,

      settings_output          RAISING lcl_error,

      init_settings_cont       RAISING lcl_error,

      init_settings_obj        RAISING lcl_error,

      handle_settings         IMPORTING iv_ucomm                     TYPE okcode,

      get_q_template    RETURNING value(rt_query)                    TYPE string_table,

      col_exp_repo,

      handle_bg_alv           IMPORTING iv_query                     TYPE string
                                        iv_upto                      TYPE i,

      check_tab_view_exists   IMPORTING iv_name                      TYPE tabname
                                RAISING lcl_error,
      ret_tabname       RETURNING value(rv_tabname)                  TYPE tabname,

      push_list               IMPORTING iv_ref                       TYPE REF TO lcl_scr,

      modif_list              IMPORTING iv_ref                       TYPE REF TO lcl_scr
                                        iv_index                     TYPE sytabix,

      read_list               IMPORTING iv_index                     TYPE syst-tabix
                        RETURNING value(rv_ref)                      TYPE REF TO lcl_scr,

      pop_list                IMPORTING iv_index                     TYPE syst-tabix,

      exec_query              IMPORTING it_query                     TYPE soli_tab
                                        iv_upto                      TYPE i
                        RETURNING value(rt_data)                     TYPE REF TO data,

      qtab_to_string          IMPORTING it_query                     TYPE soli_tab
                                        iv_com                       TYPE abap_bool OPTIONAL
                                        iv_sep                       TYPE char2 OPTIONAL
                        RETURNING value(rv_query)                    TYPE string,

      exec_query_string       IMPORTING iv_query                     TYPE string
                                        iv_upto                      TYPE i
                        RETURNING value(rt_data)                     TYPE REF TO data,


      chk_limit,



      qwiz_output               RAISING lcl_error,

      ret_query_comp          IMPORTING iv_query                     TYPE string
                        EXPORTING value(ev_select)                   TYPE string
                                  value(ev_from)                     TYPE string
                                  value(ev_where)                    TYPE string
                                  value(ev_upto)                     TYPE i
                                  value(ev_order)                    TYPE string
                                  value(ev_group)                    TYPE string,

      get_est_rows            IMPORTING iv_query                     TYPE string
                        RETURNING value(rv_rows)                     TYPE char32,

      get_ddicfields          IMPORTING iv_val                       TYPE pvarfield
                              EXPORTING et_data                      TYPE tty_ddic_fields
                                RAISING lcl_error,

      ret_whr                 IMPORTING iv_join                      TYPE abap_bool
                                        it_fld                       TYPE rsdsfields_t
                         	     CHANGING ct_whr                       TYPE rsds_twhere,

      set_visdropdown.

CLASS-METHODS:
        init_ddic_toolbar,
     set_ddic_repo_width      IMPORTING iv_width                     TYPE i,

     set_query_repo_width     IMPORTING iv_width                     TYPE i.
CLASS-DATA:
      v_repo_width     TYPE i.
  PRIVATE SECTION.

    CLASS-DATA:

      o_settings       TYPE REF TO cl_wdy_wb_property_box.

    CLASS-METHODS:
      get_new_guid      RETURNING value(rv_guid)                     TYPE guid_32,
      set_settings,

      get_settings,

      chk_ext_joinfld_loop    IMPORTING is_joinfld                   TYPE ty_joinfld
                                        iv_tab1                      TYPE tabname
                                        iv_tab2                      TYPE tabname
                        EXPORTING value(ev_exit)                      TYPE abap_bool
                               CHANGING cv_keymatch                   TYPE abap_bool,

      prep_query              IMPORTING it_whr                       TYPE rsds_twhere
                                        it_fld                       TYPE rsdsfields_t
                        RETURNING value(rt_string)                   TYPE string_table,

      get_tabfields           IMPORTING iv_tabname                   TYPE tabname
                              EXPORTING et_data                      TYPE tty_dd03vt
                                RAISING lcl_error,

      fld_sel_popup           IMPORTING it_data                      TYPE tty_dd03vt
                               CHANGING ct_fields                    TYPE tty_fields ,

      fill_tabrel,

      sqlfld_fcat       RETURNING value(rt_fcat)                     TYPE lvc_t_fcat,

      tabrel_fcat       RETURNING value(rt_fcat)                     TYPE lvc_t_fcat,

      sqlfld_disp               RAISING lcl_error,

      init_sqlfld_cont          RAISING lcl_error,

      sqlfld_alv_init           RAISING lcl_error,

      tabrel_disp               RAISING lcl_error,

      tabrel_alv_init           RAISING lcl_error,

      init_tabrel_cont          RAISING lcl_error,

      ret_fld                 IMPORTING iv_fld                       TYPE string
                                        tab1                         TYPE abap_component_tab
                                        tab2                         TYPE abap_component_tab
                        EXPORTING value(ev_skip)                     TYPE abap_bool
                                        es_tab                       TYPE abap_componentdescr,

      ret_from_tabref         IMPORTING iv_select                    TYPE string
                                        iv_from                      TYPE string
                        EXPORTING value(ev_tab)                      TYPE abap_component_tab
                                  value(ev_tab1)                     TYPE abap_component_tab,

      chk_all_wid_join        IMPORTING iv_select                    TYPE string
                                        iv_from                      TYPE string,

      ret_query_tabref        IMPORTING iv_select                    TYPE string
                                        iv_from                      TYPE string
                        EXPORTING value(rt_data)                     TYPE REF TO data
                                        et_fields                    TYPE string_table,

      exec_select             IMPORTING iv_single                    TYPE abap_bool
                                        iv_distinct                  TYPE abap_bool
                                        it_fields                    TYPE string_table
                                        iv_from                      TYPE string
                                        iv_where                     TYPE string
                                        iv_group                     TYPE string
                                        iv_order                     TYPE string
                                        iv_upto                      TYPE i
                              CHANGING  co_ref                       TYPE REF TO data,

      ret_tabfields_from_fields IMPORTING it_fields                  TYPE string_table
                                RETURNING value(rt_tabfields)        TYPE tty_tabfield,

      ret_tabfields_of_from     IMPORTING iv_from                    TYPE string
                                RETURNING value(rt_tabfields)        TYPE tty_tabfield,
      ret_tabs_of_from          IMPORTING iv_from                    TYPE string
                                RETURNING value(rt_tablist)          TYPE string_table,

      from_has_cluster_table    IMPORTING iv_from                    TYPE string
                                RETURNING value(rv_yes)              TYPE abap_bool,

      is_cluster_tab            IMPORTING iv_name                    TYPE tabname
                                RETURNING value(rv_yes)              TYPE abap_bool,



      get_sel_string    IMPORTING value(iv_join)                     TYPE abap_bool
                        RETURNING value(rt_string)                   TYPE string_table,

      ret_from                IMPORTING iv_join                      TYPE abap_bool
                              CHANGING ct_string                     TYPE string_table,

      ret_join_from_str       IMPORTING iv_tab1                      TYPE tabname
                                        iv_tab2                      TYPE tabname
                                        it_joinfld                   TYPE tty_joinfld
                               CHANGING ct_string                    TYPE string_table,

     ret_joinfld_data         EXPORTING et_joinfld                   TYPE tty_joinfld,

     ret_tab_comp             IMPORTING iv_name                      TYPE string
                        RETURNING value(rt_comp)                     TYPE abap_component_tab,



     get_type_comp            IMPORTING iv_name                      TYPE string
                        RETURNING value(rt_comp)                     TYPE abap_component_tab.

ENDCLASS.                    &quot;lcl_app DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_app IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_app IMPLEMENTATION.
  METHOD str_2_range.
    DATA:
      ls_strtab      TYPE string,
      lr_range       TYPE rsis_s_range .

    DATA:
      lt_tab         TYPE string_table.

    DATA:
      lv_str         TYPE string.

    CHECK iv_str IS NOT INITIAL.

    lv_str = iv_str.

    CONDENSE lv_str .

    SPLIT lv_str
       AT space
       INTO TABLE lt_tab.

    lr_range-sign = &apos;I&apos;.
    lr_range-option = &apos;EQ&apos;.

    LOOP AT lt_tab INTO ls_strtab.

      lr_range-low = ls_strtab.
      APPEND lr_range TO rt_rnge.

    ENDLOOP.


  ENDMETHOD.                    &quot;str_2_range
  METHOD get_new_guid.
    DO 50 TIMES.

      TRY.

          rv_guid = cl_system_uuid=&gt;create_uuid_c32_static( ).

          SELECT COUNT(*)
          FROM ztquery
          UP TO 1 ROWS
          WHERE queryid = rv_guid.

          IF syst-dbcnt = 0.
            EXIT.
          ENDIF.

        CATCH cx_uuid_error.

      ENDTRY.

    ENDDO.

  ENDMETHOD.                    &quot;get_new_guid
  METHOD save_query.
    DATA:
      ls_ztquery        TYPE ztquery.
*      lr_ugroup         LIKE LINE OF lcl_app=&gt;rt_ugroup,
*      lr_user           TYPE TRGS_USER_NAME.


    ls_ztquery = cs_ztquery.

    IF cs_ztquery-queryid IS INITIAL.
      ls_ztquery-queryid = lcl_app=&gt;get_new_guid( ).
      ls_ztquery-owner = syst-uname.
      ls_ztquery-mandt = syst-mandt.
    ENDIF.

    ls_ztquery-query = iv_query.
    ls_ztquery-text  = w-qname.
    ls_ztquery-timestamp = |{ syst-datum }{ syst-uzeit }|.
    ls_ztquery-visibility = w-qvisibility.

*    IF lcl_app=&gt;rt_ugroup IS INITIAL.
*
*      ls_ztquery-visibility_group = w-visibilitygrp.
*
*    ELSE.
*
*      LOOP AT lcl_app=&gt;rt_ugroup INTO lr_ugroup.
*
*        IF ls_ztquery-visibility_group IS INITIAL.
*
*          ls_ztquery-visibility_group = lr_ugroup-low.
*
*        ELSE.
*
*          ls_ztquery-visibility_group = |{ ls_ztquery-visibility_group } { lr_ugroup-low }|.
*
*        ENDIF.
*
*      ENDLOOP.
*
*    ENDIF.
*
*    IF lcl_app=&gt;rt_users IS INITIAL.
*
*      ls_ztquery-visibility_users = w-vis_users.
*
*    ELSE.
*
*      LOOP AT lcl_app=&gt;rt_users INTO lr_user.
*
*        IF ls_ztquery-visibility_users IS INITIAL.
*
*          ls_ztquery-visibility_users = lr_user-low.
*
*        ELSE.
*
*          ls_ztquery-visibility_users = |{ ls_ztquery-visibility_users } { lr_user-low }|.
*
*        ENDIF.
*
*      ENDLOOP.
*
*    ENDIF.

    MODIFY ztquery FROM ls_ztquery.

    IF syst-subrc IS INITIAL.
      MESSAGE s000(db) WITH &apos;Query Saved&apos;.
      cs_ztquery = ls_ztquery.
    ENDIF.

  ENDMETHOD.                    &quot;save_query
*  METHOD hndl_ugroup_multi.
*
*    DATA:
*      lrt_ugroup     TYPE RANGE OF xuclass,
*      lt_ugrp_Str    TYPE string_table.
*
*    DATA:
*      ls_restrict    TYPE rsoptions,
*      ls_inp         TYPE rstabfield,
*      ls_ugrp_str    TYPE string,
*      lr_ugroup      LIKE LINE OF lrt_ugroup.
*
*    ls_restrict-nb = &apos;X&apos;.
*    ls_restrict-bt = &apos;X&apos;.
*    ls_restrict-cp = &apos;X&apos;.
*    ls_restrict-ge = &apos;X&apos;.
*    ls_restrict-gt = &apos;X&apos;.
*    ls_restrict-le = &apos;X&apos;.
*    ls_restrict-lt = &apos;X&apos;.
*    ls_restrict-nb = &apos;X&apos;.
*    ls_restrict-ne = &apos;X&apos;.
*    ls_restrict-np = &apos;X&apos;.
*
*    IF w-visibilitygrp IS NOT INITIAL.
*
*      lr_ugroup-sign   = &apos;I&apos;.
*      lr_ugroup-option = &apos;EQ&apos;.
*
*      SPLIT me-&gt;s_ztquery-
*         at space
*       into TABLE lt_ugrp_Str.
*
*      LOOP AT lt_ugrp_Str INTO ls_ugrp_str.
*        lr_ugroup-low    = ls_ugrp_str.
*        APPEND lr_ugroup to lrt_ugroup.
*      ENDLOOP.
*
*      lr_ugroup-low    = w-visibilitygrp.
*
*      IF lrt_ugroup IS NOT INITIAL.
*
*        MODIFY lrt_ugroup FROM lr_ugroup INDEX 1.
*
*      ELSE.
*
*        APPEND lr_ugroup TO lrt_ugroup.
*
*      ENDIF.
*
**    ELSEIF lcl_app=&gt;rt_ugroup IS NOT INITIAL.
**
**      DELETE lcl_app=&gt;rt_ugroup INDEX 1.
*
*    ENDIF.
*
*    ls_inp-tablename = &apos;USR02&apos;.
*    ls_inp-fieldname = &apos;CLASS&apos;.
*
*    lcl_app=&gt;call_multisel( EXPORTING iv_excl_opt = ls_restrict
*                                      iv_input    = ls_inp
*                            CHANGING ct_rettab    = lrt_ugroup
*                          ).
*
*
*
*  ENDMETHOD.                    &quot;hndl_ugroup_multi
*  METHOD hndl_vuser_multi.
*
*    DATA:
*      lr_vuser       LIKE LINE OF lcl_app=&gt;rt_users.
*
*    DATA:
*      ls_restrict    TYPE rsoptions,
*      ls_inp         TYPE rstabfield.
*
*    ls_restrict-nb = &apos;X&apos;.
*    ls_restrict-bt = &apos;X&apos;.
*    ls_restrict-cp = &apos;X&apos;.
*    ls_restrict-ge = &apos;X&apos;.
*    ls_restrict-gt = &apos;X&apos;.
*    ls_restrict-le = &apos;X&apos;.
*    ls_restrict-lt = &apos;X&apos;.
*    ls_restrict-nb = &apos;X&apos;.
*    ls_restrict-ne = &apos;X&apos;.
*    ls_restrict-np = &apos;X&apos;.
*
*    IF w-vis_users IS NOT INITIAL.
*
*      lr_vuser-sign   = &apos;I&apos;.
*      lr_vuser-option = &apos;EQ&apos;.
*      lr_vuser-low    = w-vis_users.
*
*      IF lcl_app=&gt;rt_users IS NOT INITIAL.
*
*        MODIFY lcl_app=&gt;rt_users FROM lr_vuser INDEX 1.
*
*      ELSE.
*
*        APPEND lr_vuser TO lcl_app=&gt;rt_users.
*
*      ENDIF.
*
*    ELSEIF lcl_app=&gt;rt_users IS NOT INITIAL.
*
*      DELETE lcl_app=&gt;rt_users INDEX 1.
*
*    ENDIF.
*
*    ls_inp-tablename = &apos;USR02&apos;.
*    ls_inp-fieldname = &apos;BNAME&apos;.
*
*    lcl_app=&gt;call_multisel( EXPORTING iv_excl_opt = ls_restrict
*                                      iv_input    = ls_inp
*                            CHANGING  ct_rettab   = lcl_app=&gt;rt_users
*                           ).
*
*  ENDMETHOD.                    &quot;hndl_ugroup_multi
  METHOD call_multisel.

    CALL FUNCTION &apos;COMPLEX_SELECTIONS_DIALOG&apos;
      EXPORTING
        title            = &apos;Multiple Selection&apos;
        signed           = &apos;X&apos;
        just_display     = &apos;&apos;
        just_incl        = &apos;X&apos;
        excluded_options = iv_excl_opt &quot;exclude_options -By PKUCHU for ATC
        search_help      = iv_hlpname &quot;hlpname - By PKUCHU for ATC
        tab_and_field    = iv_input &quot;input - By PKUCHU for ATC
      TABLES
        range            = ct_rettab &quot;rettab - By PKUCHU for ATC
      EXCEPTIONS
        cancelled        = 0
        OTHERS           = 1.

    IF sy-subrc &lt;&gt; 0.
      REFRESH ct_rettab.
    ENDIF.

  ENDMETHOD.                    &quot;call_multisel
  METHOD rfrsh_qwiz_data.

    CLEAR :
       lcl_app=&gt;t_sqlfld[],
       lcl_app=&gt;t_tabrel[].

  ENDMETHOD.                    &quot;rfrsh_qwiz_data
  METHOD popup_get_values.

    DATA:
      lt_sval        TYPE ty_sval.
    DATA:
      lv_returncode  TYPE c.

    APPEND cs_sval TO lt_sval.

    CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
      EXPORTING
        popup_title     = space
      IMPORTING
        returncode      = lv_returncode
      TABLES
        fields          = lt_sval
      EXCEPTIONS
        error_in_fields = 1
        OTHERS          = 2.

    IF sy-subrc NE 0
    OR lv_returncode NE space.
      ev_exit = abap_true. &quot;exit do
    ENDIF.

    READ TABLE lt_sval INTO cs_sval INDEX 1.

    IF cs_sval-value = space.
      ev_exit = abap_true.
    ENDIF.


  ENDMETHOD.                    &quot;popup_get_values
  METHOD ret_ora_whr_str.

    DATA:
      lv_whr      TYPE string,
      lv_upto     TYPE i.

    CHECK iv_whr  IS NOT INITIAL
      OR  iv_upto IS NOT INITIAL.

    lv_whr  = iv_whr.
    lv_upto = iv_upto.

    IF  lv_upto IS INITIAL
    AND lcl_app=&gt;default_rows IS NOT INITIAL.

      lv_upto = lcl_app=&gt;default_rows.

    ENDIF.

    rv_whr_str = &apos;WHERE&apos;.

    IF lv_whr IS NOT INITIAL.

      REPLACE ALL OCCURRENCES OF &apos; NE &apos; IN lv_whr WITH &apos;&lt;&gt;&apos;.
      REPLACE ALL OCCURRENCES OF &apos; EQ &apos; IN lv_whr WITH &apos;=&apos;.
      REPLACE ALL OCCURRENCES OF &apos; GE &apos; IN lv_whr WITH &apos;=&gt;&apos;.
      REPLACE ALL OCCURRENCES OF &apos; LE &apos; IN lv_whr WITH &apos;&lt;=&apos;.

      rv_whr_str = |{ rv_whr_str } { lv_whr } |.

      IF lv_upto IS NOT INITIAL.
        rv_whr_str = |{ rv_whr_str } AND|.
      ENDIF.

    ENDIF.

    IF lv_upto IS NOT INITIAL.
      rv_whr_str = |{ rv_whr_str } ROWNUM &lt;= { rv_whr_str } |.
    ENDIF.


  ENDMETHOD.                    &quot;ret_ora_whr_str
  METHOD call_sel_screen.
    DATA:
      lv_selid TYPE rsdynsel-selid.

    CLEAR:
      et_where[].

    CALL FUNCTION &apos;FREE_SELECTIONS_INIT&apos;
      EXPORTING
        kind         = &apos;F&apos;
      IMPORTING
        selection_id = lv_selid
      TABLES
        fields_tab   = ct_fld
      EXCEPTIONS
        OTHERS       = 1.
    IF sy-subrc &lt;&gt; 0.
* Implement suitable error handling here
      RETURN.

    ENDIF.

    CALL FUNCTION &apos;FREE_SELECTIONS_DIALOG&apos;
      EXPORTING
        selection_id  = lv_selid
        title         = &apos;Select data&apos;
        as_window     = &apos;X&apos;
        tree_visible  = &apos; &apos;
      IMPORTING
        where_clauses = et_where
      TABLES
        fields_tab    = ct_fld
      EXCEPTIONS
        OTHERS        = 1.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

  ENDMETHOD.                    &quot;sel_screen
  METHOD ret_query.

    DATA:
      ls_sqlfld TYPE ty_sqlfields,
      ls_fld    TYPE rsdsfields.

    DATA:
      lv_selid  TYPE rsdynsel-selid.

    DATA:
      lt_fld    TYPE STANDARD TABLE OF rsdsfields,
      lt_where  TYPE rsds_twhere.

    w-o_sqlfld_alv-&gt;check_changed_data( ).

    w-o_tabrel_alv-&gt;check_changed_data( ).

    READ TABLE t_sqlfld INTO ls_sqlfld WITH KEY input = abap_true.

    IF syst-subrc IS INITIAL.

      LOOP AT t_sqlfld INTO ls_sqlfld WHERE input = abap_true.
        ls_fld-tablename = ls_sqlfld-tabname.
        ls_fld-fieldname = ls_sqlfld-fieldname.
        APPEND ls_fld TO lt_fld.
      ENDLOOP.

      lcl_app=&gt;call_sel_screen( IMPORTING et_where = lt_where
                                 CHANGING ct_fld   = lt_fld
                              ).

    ENDIF.

    rt_string = lcl_app=&gt;prep_query( it_whr    = lt_where
                                     it_fld    = lt_fld
                                   ).
    CLEAR:
      lcl_app=&gt;t_tabrel,
      lcl_app=&gt;t_sqlfld.

  ENDMETHOD.                    &quot;ret_query

  METHOD chk_tabnm_empt_vald.
    DATA:
      lv_tabname   TYPE tabname.

    IF iv_tabname IS INITIAL.

      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Table Name Empty!&apos;.

    ELSE.

      lv_tabname = iv_tabname.

      CONDENSE lv_tabname.

      lcl_app=&gt;check_tab_view_exists( lv_tabname ).

    ENDIF.

  ENDMETHOD.                    &quot;chk_tabnm_empt_vald
  METHOD handle_sqlfld.
*   Internal Table*
    DATA :
      lt_dd03vt     TYPE STANDARD TABLE OF ty_dd03vt .

    DATA :
      lv_tabname    TYPE tabname.

    lv_tabname = iv_tabname.

    CONDENSE lv_tabname.

    lcl_app=&gt;get_tabfields( EXPORTING iv_tabname = lv_tabname
                            IMPORTING et_data    = lt_dd03vt
                          ).


    lcl_app=&gt;fld_sel_popup( EXPORTING it_data   = lt_dd03vt
                             CHANGING ct_fields = t_sqlfld
                          ).

    IF t_sqlfld IS INITIAL.

      RETURN.

    ENDIF.

    lcl_app=&gt;fill_tabrel( ).

  ENDMETHOD.                    &quot;handle_sqlfld
  METHOD fill_tabrel.
    DATA:
      lt_sqlfields  TYPE STANDARD TABLE OF ty_sqlfields .

    DATA:
      ls_tabrel     TYPE ty_tabrel,
      ls_sqlfld     TYPE ty_sqlfields.

    lt_sqlfields = t_sqlfld.

    SORT lt_sqlfields  BY tabname.

    DELETE ADJACENT DUPLICATES FROM lt_sqlfields COMPARING tabname.

    CLEAR:
      t_tabrel[].

    LOOP AT lt_sqlfields INTO ls_sqlfld.

      IF ls_tabrel-tabname1 IS INITIAL.
        ls_tabrel-tabname1 = ls_sqlfld-tabname.
      ENDIF.

      IF ls_tabrel-tabname1  &lt;&gt; ls_sqlfld-tabname.
        ls_tabrel-rel_txt = &apos;INNER JOIN&apos;.
        ls_tabrel-tabname2 = ls_sqlfld-tabname.
        APPEND ls_tabrel TO t_tabrel.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    &quot;fill_tabrel
  METHOD check_tab_view_exists.

    SELECT COUNT(*)
           FROM dd02l
           UP TO 1 ROWS
           WHERE tabname = iv_name
             AND as4local = &apos;A&apos;
             AND tabclass IN (&apos;TRANSP&apos; , &apos;VIEW&apos; , &apos;CLUSTER&apos;).

    IF syst-dbcnt &lt;&gt; 1.
      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Table/View does not exists&apos;.
    ENDIF.
  ENDMETHOD.                    &quot;check_tab_view_exists
  METHOD set_settings.

    DATA:
      lt_ptab  TYPE wdy_wb_property_tab.

    DATA:
      ls_ptab  TYPE wdy_wb_property.

    CHECK lcl_app=&gt;o_settings IS NOT INITIAL.

*      * If not first display, refresh properties values
    lt_ptab = lcl_app=&gt;o_settings-&gt;get_properties( ).

    LOOP AT lt_ptab INTO ls_ptab.

      CASE ls_ptab-name.

        WHEN &apos;PB&apos;.
          ls_ptab-value = lcl_app=&gt;paste_break.

        WHEN &apos;MAXROWS&apos;.
          ls_ptab-value = lcl_app=&gt;default_rows.

        WHEN &apos;TECH&apos;.
          ls_ptab-value = lcl_app=&gt;techname.

        WHEN &apos;CONVERSION&apos;.
          ls_ptab-value = lcl_app=&gt;conversion.

      ENDCASE.

    ENDLOOP.

    lcl_app=&gt;o_settings-&gt;set_properties( properties = lt_ptab    &quot; Web Dynpro Tools Property Box: Table with Properties
                                         refresh    = abap_true    &quot; General Flag
                                       ).

  ENDMETHOD.                    &quot;set_settings

  METHOD get_settings.

    DATA:
      lt_ptab  TYPE wdy_wb_property_tab.

    DATA:
      ls_ptab  TYPE wdy_wb_property.

    lt_ptab = lcl_app=&gt;o_settings-&gt;get_properties( ).

    LOOP AT lt_ptab INTO ls_ptab.
      CASE ls_ptab-name.
        WHEN &apos;PB&apos;.
          lcl_app=&gt;paste_break = ls_ptab-value.
        WHEN &apos;MAXROWS&apos;.
          lcl_app=&gt;default_rows = ls_ptab-value.
        WHEN &apos;TECH&apos;.
          lcl_app=&gt;techname = ls_ptab-value.
        WHEN &apos;CONVERSION&apos;.
          lcl_app=&gt;conversion = ls_ptab-value .
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_Settings

  METHOD handle_settings.

    DATA:
   	  lv_ucomm TYPE syucomm.

    lcl_app=&gt;set_settings( ).
*
** Display properties panel
    CALL SCREEN 9200 STARTING AT 60 10
    ENDING AT 90 16.

    IF w_okcode NE &apos;OK_SET&apos;.
      RETURN.
    ENDIF.
*
    lv_ucomm = iv_ucomm.
*** Update values if not well refreshed in o_settings
    lcl_app=&gt;o_settings-&gt;dispatch(  EXPORTING cargo             = lv_ucomm
                                              eventid           = 18
                                              is_shellevent     = space
                                              is_systemdispatch = space
                                   EXCEPTIONS OTHERS            = 0
                                 ).

* Update values
    lcl_app=&gt;get_settings( ).
  ENDMETHOD.                    &quot;handle_settings
  METHOD init_settings_cont.

    IF w-o_container_options IS INITIAL.

      CREATE OBJECT w-o_container_options
        EXPORTING
          container_name = &apos;CUSTCONT2&apos;
        EXCEPTIONS
          others         = 6.

      IF sy-subrc &lt;&gt; 0.
        RAISE EXCEPTION TYPE lcl_error
          EXPORTING
            iv_text = &apos;Error Initialising Settings Container.&apos;.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    &quot;init_settings_cont
  METHOD init_settings_obj.
    DATA:
      lt_ptab TYPE wdy_wb_property_tab,
      ls_ptab TYPE wdy_wb_property.:

    IF lcl_app=&gt;o_settings IS INITIAL.
* Create the property object and link it to the custom controm
    CREATE OBJECT lcl_app=&gt;o_settings
      EXPORTING
        parent = w-o_container_options
      EXCEPTIONS
        others = 4.

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Error Initialising Settings.&apos;.
    ENDIF.

* Defi Column title of the property object
    lcl_app=&gt;o_settings-&gt;initialize( property_column_title = &apos;Property&apos;
                                     value_column_title    = &apos;Value&apos;
                                     focus_row             = 1
                                     scrollable            = abap_true
                                    ).

    lcl_app=&gt;o_settings-&gt;set_enabled( abap_true ).

* pastbreak
    ls_ptab-name    = &apos;PB&apos;.
    ls_ptab-type    = cl_wdy_wb_property_box=&gt;property_type_boolean.
    ls_ptab-enabled = abap_true.
    ls_ptab-value   = lcl_app=&gt;paste_break.

    CONCATENATE &apos;@74\Q&apos;
    &apos;Add break line after pasting ddic field into sql editor&apos;
    &apos;@&apos; &apos;Line Break&apos; INTO ls_ptab-display_name.

    APPEND ls_ptab TO lt_ptab.

* defat up to xxx rows
    ls_ptab-name    = &apos;MAXROWS&apos;.
    ls_ptab-type    = cl_wdy_wb_property_box=&gt;property_type_integer.
    ls_ptab-enabled = abap_true.
    ls_ptab-value   = lcl_app=&gt;default_rows.

    CONCATENATE &apos;@3W\Q&apos;
    &apos;Default max number of displayed lines for SELECT&apos;
    &apos;@&apos; &apos;Max Rows&apos; INTO ls_ptab-display_name.
    APPEND ls_ptab TO lt_ptab.

* defat up to xxx rows
    ls_ptab-name    = &apos;TECH&apos;.
    ls_ptab-type    = cl_wdy_wb_property_box=&gt;property_type_boolean.
    ls_ptab-enabled = abap_true.
    ls_ptab-value   = lcl_app=&gt;techname.

    CONCATENATE &apos;@AJ\Q&apos;
    &apos;Display technical name in query result display&apos;
    &apos;@&apos; &apos;Technical name&apos; INTO ls_ptab-display_name.

    APPEND ls_ptab TO lt_ptab.

    ls_ptab-name    = &apos;CONVERSION&apos;.
    ls_ptab-type    = cl_wdy_wb_property_box=&gt;property_type_boolean.
    ls_ptab-enabled = abap_true.
    ls_ptab-value   = lcl_app=&gt;conversion.

    CONCATENATE &apos;@AJ\Q&apos;
    &apos;Display data with Conversion&apos;
    &apos;@&apos; &apos;Conversion Exit&apos; INTO ls_ptab-display_name.

    APPEND ls_ptab TO lt_ptab.


* Fillroperties/values
    lcl_app=&gt;o_settings-&gt;set_properties( properties = lt_ptab
                                         refresh    = abap_true
                                       ).

  ENDIF.

ENDMETHOD.                    &quot;init_settings_obj
METHOD settings_output.

  lcl_app=&gt;init_settings_cont( ).

  lcl_app=&gt;init_settings_obj( ).

ENDMETHOD.                    &quot;settings_output
METHOD get_q_template.

  APPEND &apos;&apos; TO rt_query.
  APPEND &apos;SELECT *&apos; TO rt_query.                            &quot;#EC NOTEXT
  APPEND &apos;FROM &lt;table_name&gt;&apos; TO rt_query.                   &quot;#EC NOTEXT

  APPEND &apos;WHERE &lt;conditions&gt;&apos; TO rt_query.                  &quot;#EC NOTEXT
  APPEND &apos;.&apos; TO rt_query.                                   &quot;#EC NOTEXT

ENDMETHOD.                    &quot;get_q_template
METHOD set_visdropdown.

  DATA:
    lt_visibility TYPE vrm_values,
    ls_visibility TYPE vrm_value.

  ls_visibility-key  = &apos;0&apos;.
  ls_visibility-text = &apos;Personal&apos;.
  APPEND ls_visibility TO lt_visibility.

  ls_visibility-key  = &apos;1&apos;.
  ls_visibility-text = &apos;User group&apos;.
  APPEND ls_visibility TO lt_visibility.

  ls_visibility-key  = &apos;2&apos;.
  ls_visibility-text = &apos;All&apos;.
  APPEND ls_visibility TO lt_visibility.

  CALL FUNCTION &apos;VRM_SET_VALUES&apos;
    EXPORTING
      id     = &apos;W-QVISIBILITY&apos;
      values = lt_visibility.


ENDMETHOD.                    &quot;set_visdropdown
METHOD col_exp_repo.

  IF lcl_app=&gt;v_repo_width &gt; 0.
    lcl_app=&gt;v_repo_width = 0.
  ELSE.
    lcl_app=&gt;v_repo_width = 20.
  ENDIF.

  lcl_app=&gt;set_ddic_repo_width( lcl_app=&gt;v_repo_width ).
  lcl_app=&gt;set_query_repo_width( lcl_app=&gt;v_repo_width ).


ENDMETHOD.                    &quot;col_exp_repo
METHOD get_est_rows.
  DATA ora_par TYPE STANDARD TABLE OF   oraexplpar .
  DATA values TYPE STANDARD TABLE OF  expl_value .
  DATA subrc TYPE sysubrc.
  DATA lv_len TYPE i.
  DATA lv_string      TYPE string.
  DATA :
              card_p(16)         TYPE p.
*      cardinality(32)    TYPE c.
  FIELD-SYMBOLS:&lt;lf_plan&gt; TYPE any.
  FIELD-SYMBOLS:&lt;lf_rows&gt; TYPE any.
  FIELD-SYMBOLS:
*    &lt;lfs_data&gt;         TYPE STANDARD TABLE,
  &lt;lfs_plan&gt;         TYPE STANDARD TABLE.
  lv_string =  iv_query.

  CONDENSE lv_string.

  lv_len = strlen( lv_string ).

  PERFORM before_explain_plan IN PROGRAM rsxplora
                                         TABLES ora_par.

  PERFORM db_explain_plan IN PROGRAM rsxplora  TABLES values ora_par USING lv_string lv_len
                         CHANGING subrc.

  IF subrc IS NOT INITIAL.
    RETURN.
  ENDIF.
  PERFORM read_plan_table_ora9 IN PROGRAM rsxplora USING lv_string.

  ASSIGN (&apos;(RSXPLORA)_plan_table_tab[]&apos;) TO &lt;lfs_plan&gt;.


  DATA:id TYPE string VALUE &apos;ID&apos;.

  IF &lt;lfs_plan&gt; IS NOT ASSIGNED
  OR &lt;lfs_plan&gt; IS INITIAL .

    RETURN.

  ENDIF.
  READ TABLE &lt;lfs_plan&gt; ASSIGNING &lt;lf_plan&gt; WITH KEY (id) = 0.

  IF syst-subrc &lt;&gt; 0
  OR &lt;lf_plan&gt; IS NOT ASSIGNED.
    RETURN.

  ENDIF.

  ASSIGN COMPONENT &apos;CARDINALITY&apos; OF STRUCTURE &lt;lf_plan&gt; TO &lt;lf_rows&gt;.

  IF &lt;lf_rows&gt; IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  card_p = &lt;lf_rows&gt;.
  WRITE card_p TO rv_rows LEFT-JUSTIFIED.

  REFRESH &lt;lfs_plan&gt;.


ENDMETHOD.                    &quot;get_est_rows
METHOD get_ddicfields.

  SELECT dd03l~tabname
         dd03l~fieldname
         dd03l~position
         dd03l~keyflag
         dd03m~scrtext_l
         INTO TABLE et_data
               FROM dd03l LEFT OUTER JOIN dd03m
                 ON dd03l~tabname    = dd03m~tabname
                AND dd03l~fieldname  = dd03m~fieldname
                AND dd03m~ddlanguage = sy-langu
              WHERE dd03l~tabname    = iv_val
                AND dd03l~as4local   = &apos;A&apos;
                AND dd03l~as4vers    = space
                AND ( dd03l~comptype = &apos;E&apos;
                   OR dd03l~comptype = space ).

  IF syst-subrc  IS NOT INITIAL.
    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;No Data Found for Input Table!&apos;.
  ENDIF.

ENDMETHOD.                    &quot;get_ddicfields
* itialise all the containers.
*METHOD init.
*
*  CHECK w-o_container IS INITIAL.
**  CHECK lcl_scr=&gt;o_container IS INITIAL.
** Create the custom container
*  CREATE OBJECT w-o_container
*    EXPORTING
*      container_name = &apos;CUSTCONT&apos;
*    EXCEPTIONS
*      others         = 6.
*
*  IF syst-subrc &lt;&gt; 0.
*
*    RETURN.
*
*  ENDIF.
**       Split to 3 Columns.
*  CREATE OBJECT w-o_splitter
*    EXPORTING
*      parent  = w-o_container
*      rows    = 1
*      columns = 3
*    EXCEPTIONS
*      others  = 3.
*
*  IF syst-subrc &lt;&gt; 0.
*
*    RETURN.
*
*  ENDIF.
*
**   Set Query Container.
*  w-o_qcontainer = w-o_splitter-&gt;get_container( row       = 1
*                                                column    = 2
*
*                                               ).
*
**       ********************************************************************
**       &lt;DDIC Repository&gt;&gt;
*
**         Set DDIC Container
*  w-o_container_ddic_full = w-o_splitter-&gt;get_container( row       = 1
*                                                         column    = 3
*                                                       ).
*
**       ***  toolbar on DDIC container
*  CREATE OBJECT w-o_splitter_ddic_full
*    EXPORTING
*      i_r_container = w-o_container_ddic_full.
*
**       * DDIC tree container
*  w-o_container_ddic = w-o_splitter_ddic_full-&gt;get_controlcontainer( ).
*
**         Initiate Toolbar
*  lcl_app=&gt;init_ddic_toolbar( ).
*
*
**       ****************************************************************
**       &lt;Queepository&gt;&gt;
*  w-o_container_qrep = w-o_splitter-&gt;get_container( row       = 1
*                                                    column    = 1
*                                                  ).
*
*  lcl_app=&gt;v_repo_width = 20.
*
*  lcl_app=&gt;set_ddic_repo_width( lcl_app=&gt;v_repo_width ).
*
*  lcl_app=&gt;set_query_repo_width( lcl_app=&gt;v_repo_width ).
*
*  rv_allok = abap_true.
*
*ENDMETHOD.                    &quot;init
METHOD set_ddic_repo_width.
* t DDIC and Query Repo to 20 percent of screen each.

  w-o_splitter-&gt;set_column_width(  EXPORTING id                = 3
                                             width             = iv_width
                                  EXCEPTIONS OTHERS            = 0
                                ).

*  IF syst-subrc &lt;&gt; 0.
** WOuld Handle error Later.
*  ENDIF.


ENDMETHOD.                    &quot;set_ddic_repo_width
METHOD set_query_repo_width.
* t DDIC and Query Repo to 20 percent of screen each.

  w-o_splitter-&gt;set_column_width( EXPORTING id                = 1
                                            width             = iv_width
                                 EXCEPTIONS OTHERS            = 0
                                ).



ENDMETHOD.                    &quot;set_query_repo_width
METHOD handle_bg_alv.

  DATA:
    lo_data    TYPE REF TO data,
    lo_salv    TYPE REF TO cl_salv_table.

  FIELD-SYMBOLS:
    &lt;lfs_data&gt; TYPE STANDARD TABLE.

  lo_data = lcl_app=&gt;exec_query_string( iv_query = iv_query
                                        iv_upto  = iv_upto
                                      ).

  ASSIGN lo_data-&gt;* TO &lt;lfs_data&gt;.

  IF &lt;lfs_data&gt; IS NOT ASSIGNED
  OR &lt;lfs_data&gt; IS  INITIAL.

    RETURN.

  ENDIF.

  cl_salv_table=&gt;factory( IMPORTING r_salv_table   =   lo_salv  &quot; Basis Class Simple ALV Tables
                           CHANGING t_table        = &lt;lfs_data&gt;
                        ).

  lo_salv-&gt;display( ).

ENDMETHOD.                    &quot;handle_bg_alv
METHOD init_ddic_toolbar.

  DATA:
    lt_button TYPE ttb_button,
    ls_button TYPE stb_button,
    lt_events TYPE cntl_simple_events,
    ls_events TYPE cntl_simple_event.

**Get toolbar object.
  w-o_toolbar = w-o_splitter_ddic_full-&gt;get_toolbar( ).

  IF w-o_toolbar IS  INITIAL.

    RETURN.

  ENDIF.

* fine buttons for Toolbar.
  CLEAR ls_button.
  ls_button-function   = &apos;RFRS_DD_TRE&apos;.
  ls_button-icon       = &apos;@42@&apos;.
  ls_button-quickinfo  = &apos;Refresh DDIC tree&apos;.
  ls_button-text       = &apos;Refresh&apos;.
  ls_button-butn_type  = 0.

  APPEND ls_button TO lt_button.

  CLEAR ls_button.
  ls_button-function   = &apos;FIND&apos;.
  ls_button-icon       = &apos;@13@&apos;.
  ls_button-quickinfo  = &apos;Search in DDIC tree&apos;.
  ls_button-text       = &apos;Find&apos;.
  ls_button-butn_type  = 0.

  APPEND ls_button TO lt_button.

  CLEAR ls_button.
  ls_button-function   = &apos;SET_FLD_IP&apos;.
  ls_button-icon       = &apos;@6T@&apos;.
  ls_button-quickinfo  = &apos;Push As Input&apos;.
  ls_button-text       = &apos;Set Input&apos;.
  ls_button-butn_type  = 0.
  APPEND ls_button TO lt_button.

  ls_button-function   = &apos;ADD&apos;.
  ls_button-quickinfo  = &apos;Add Table&apos;.
  ls_button-text       = &apos;ADD&apos;.
  ls_button-butn_type  = 0.
  APPEND ls_button TO lt_button.


* d Button and register.

  w-o_toolbar-&gt;add_button_group( EXPORTING data_table       = lt_button
                                EXCEPTIONS OTHERS           = 1
                               ).

  IF syst-subrc &lt;&gt; 0.
*   Would raise error later.
  ENDIF.

  ls_events-eventid = cl_gui_toolbar=&gt;m_id_function_selected.
  APPEND ls_events TO lt_events.

  w-o_toolbar-&gt;set_registered_events( EXPORTING events                    = lt_events
                                     EXCEPTIONS OTHERS                    = 1
    ).

  IF syst-subrc &lt;&gt; 0.
*   Would raise error later.
  ENDIF.

ENDMETHOD.                    &quot;init_ddic_toolbar
METHOD tabrel_fcat.

  DATA:
    ls_fcat   TYPE lvc_s_fcat,
    ls_result TYPE abap_componentdescr.

  DATA:
    lt_result TYPE abap_component_tab.

  lt_result = lcl_app=&gt;get_type_comp( &apos;TY_TABREL&apos; ).

  LOOP AT lt_result INTO ls_result.

    CLEAR ls_fcat.
    ls_fcat-fieldname = to_upper( ls_result-name ).
    ls_fcat-scrtext_m = to_upper( ls_result-name ).

    IF ls_fcat-fieldname = &apos;REL_TXT&apos;.

      ls_fcat-edit      = &apos;X&apos;.
      ls_fcat-drdn_hndl = 1.

    ENDIF.

    APPEND ls_fcat TO rt_fcat.

  ENDLOOP.

ENDMETHOD.                    &quot;tabrel_fcat
METHOD get_type_comp.

  DATA:
    lo_type   TYPE REF TO cl_abap_typedescr,
    lo_struc  TYPE REF TO cl_abap_structdescr.


  cl_abap_structdescr=&gt;describe_by_name( EXPORTING p_name         = iv_name    &quot; Type name
                                         RECEIVING p_descr_ref    = lo_type
                                         EXCEPTIONS OTHERS         = 2
                                        ).

  IF sy-subrc &lt;&gt; 0.
    RETURN.
  ENDIF.

  lo_struc ?= lo_type.

  rt_comp   =  lo_struc-&gt;get_components( ).

ENDMETHOD.                    &quot;get_type_comp
METHOD sqlfld_fcat.

  DATA:
    ls_fcat   TYPE lvc_s_fcat,
    ls_result TYPE abap_componentdescr.

  DATA:
    lt_result TYPE abap_component_tab.

  lt_result = lcl_app=&gt;get_type_comp( &apos;TY_SQLFIELDS&apos; ).

  LOOP AT lt_result INTO ls_result.

    CLEAR ls_fcat.

    ls_fcat-fieldname = to_upper( ls_result-name ).
    ls_fcat-scrtext_m = to_upper( ls_result-name ).

    IF ls_fcat-fieldname = &apos;INPUT&apos;.

      ls_fcat-checkbox = c-x.
      ls_fcat-edit     = c-x.

    ENDIF.

    APPEND ls_fcat TO rt_fcat.

  ENDLOOP.


ENDMETHOD.                    &quot;sqlfld_fcat
METHOD init_sqlfld_cont.

  IF w-o_sqlfld_cont IS INITIAL.

    CREATE OBJECT w-o_sqlfld_cont
      EXPORTING
        container_name = &apos;CONT_SQLFIELDS&apos;
      EXCEPTIONS
        others         = 1.

    IF syst-subrc &lt;&gt; 0.

      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Error Initialising SQL Fields Container.&apos;.
    ENDIF.

  ENDIF.

ENDMETHOD.                    &quot;init_sqlfld_cont
METHOD sqlfld_disp.

  lcl_app=&gt;init_sqlfld_cont( ).

  IF w-o_sqlfld_alv IS INITIAL.

    lcl_app=&gt;sqlfld_alv_init( ).

  ELSE.

    w-o_sqlfld_alv-&gt;refresh_table_display( EXCEPTIONS OTHERS      = 1 ).

    IF sy-subrc &lt;&gt; 0.

      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Error Refreshing Data.&apos;.

    ENDIF.

  ENDIF.

ENDMETHOD.                    &quot;sqlfld_disp
METHOD sqlfld_alv_init.

  DATA:
    lt_fcat TYPE lvc_t_fcat.

  DATA:
    ls_layo TYPE lvc_s_layo.

  CREATE OBJECT w-o_sqlfld_alv
    EXPORTING
      i_parent = w-o_sqlfld_cont
    EXCEPTIONS
      others   = 1.

  IF  syst-subrc &lt;&gt; 0.

    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;Error Initialising SQL Fields ALV&apos;.

  ENDIF.

  lt_fcat = lcl_app=&gt;sqlfld_fcat( ).

  ls_layo-no_toolbar = c-x.

  w-o_sqlfld_alv-&gt;set_table_for_first_display(  EXPORTING is_layout                     = ls_layo   &quot; Layout
                                                 CHANGING it_outtab                     = t_sqlfld  &quot; Output Table
                                                          it_fieldcatalog               = lt_fcat   &quot; Field Catalog
                                               EXCEPTIONS OTHERS                        = 1
                                             ).

  IF sy-subrc &lt;&gt; 0.
    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;Error Initialising SQL Fields ALV&apos;.
  ENDIF.


ENDMETHOD.                    &quot;sqlfld_alv_init
METHOD tabrel_alv_init.
  DATA:
    lt_fcat TYPE lvc_t_fcat,
    lt_drdn TYPE lvc_t_drop.

  DATA:
    ls_layo TYPE lvc_s_layo,
    ls_drdn TYPE lvc_s_drop.

  CREATE OBJECT w-o_tabrel_alv
    EXPORTING
      i_parent = w-o_tabrel_cont
    EXCEPTIONS
      others   = 1.

  IF w-o_tabrel_alv IS INITIAL.

    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;Error Initialising Table Relations ALV&apos;.

  ENDIF.

  lt_fcat = lcl_app=&gt;tabrel_fcat( ).

  ls_layo-no_toolbar = c-x.

  ls_drdn-handle     = 1.

  ls_drdn-value   = &apos;INNER JOIN&apos;.
  APPEND ls_drdn TO lt_drdn.

  ls_drdn-value   = &apos;LEFT OUTER JOIN&apos;.
  APPEND ls_drdn TO lt_drdn.

  w-o_tabrel_alv-&gt;set_drop_down_table( it_drop_down = lt_drdn  ).&quot; Dropdown Table

  w-o_tabrel_alv-&gt;set_table_for_first_display( EXPORTING is_layout                     =  ls_layo   &quot; Layout
                                                CHANGING it_outtab                     =  t_tabrel   &quot; Output Table
                                                         it_fieldcatalog               =  lt_fcat   &quot; Field Catalog
                                              EXCEPTIONS OTHERS                        = 1
                                             ).

  IF sy-subrc &lt;&gt; 0.

    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;Error Initialising Table Relations ALV&apos;.

  ENDIF.

ENDMETHOD.                    &quot;tabrel_alv_init
METHOD tabrel_disp.

  lcl_app=&gt;init_tabrel_cont( ).

  IF w-o_tabrel_alv IS INITIAL.

    lcl_app=&gt;tabrel_alv_init( ).

  ELSE.

    w-o_tabrel_alv-&gt;refresh_table_display( EXCEPTIONS OTHERS         = 1      ).

    IF sy-subrc &lt;&gt; 0.

      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Error Refreshing Data.&apos;.

    ENDIF.

  ENDIF.

ENDMETHOD.                    &quot;tabrel_disp
METHOD init_tabrel_cont.

  IF w-o_tabrel_cont IS INITIAL.

    CREATE OBJECT w-o_tabrel_cont
      EXPORTING
        container_name = &apos;CONT_TABREL&apos;
      EXCEPTIONS
        others         = 1.

    IF syst-subrc &lt;&gt; 0.

      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Error Initialising Table Relation Container.&apos;.

    ENDIF.
  ENDIF.

ENDMETHOD.                    &quot;init_tabrel_cont
METHOD qwiz_output.

  lcl_app=&gt;sqlfld_disp( ).

  lcl_app=&gt;tabrel_disp( ).

ENDMETHOD.                    &quot;qwiz_output
METHOD get_sel_string.

  DATA :
    lv_sel      TYPE string.

  DATA:
    ls_sqlfld TYPE ty_sqlfields.

  lv_sel = &apos;SELECT&apos;.

  LOOP AT t_sqlfld INTO ls_sqlfld.
    IF iv_join = abap_true.

      lv_sel = |{ lv_sel } { ls_sqlfld-tabname }~{ ls_sqlfld-fieldname }|.
    ELSE.
      lv_sel = |{ lv_sel }  { ls_sqlfld-fieldname }|.
    ENDIF.
    APPEND lv_sel TO rt_string.
    CLEAR lv_sel.
  ENDLOOP.

ENDMETHOD.                    &quot;get_sel_string
METHOD ret_joinfld_data.
  CHECK t_tabrel IS NOT INITIAL.
  SELECT dd03l~tabname
         dd03l~fieldname
         dd03m~tabname
         dd03l~position
         dd03l~keyflag
         dd03m~keyflag
  FROM dd03l INNER JOIN dd03m
  ON dd03l~fieldname = dd03m~fieldname
  INTO TABLE et_joinfld
  FOR ALL ENTRIES IN t_tabrel
  WHERE dd03l~tabname = t_tabrel-tabname1
  AND dd03m~tabname = t_tabrel-tabname2
  AND dd03m~ddlanguage = &apos;E&apos; .

ENDMETHOD.                    &quot;ret_joinfld_Data
METHOD ret_from.
  DATA:
    ls_tabrel   TYPE ty_tabrel,
    ls_sqlfld   TYPE ty_sqlfields.

  DATA:
    lv_from     TYPE string.

  DATA:
    lt_joinfld  TYPE STANDARD TABLE OF ty_joinfld.

  lv_from = &apos;FROM&apos;.

  IF iv_join = abap_true.

*    CLEAR lv_keymatch.

    lcl_app=&gt;ret_joinfld_data( IMPORTING et_joinfld = lt_joinfld ).

    SORT lt_joinfld BY tab1
                       tab2
                       position.

    LOOP AT t_tabrel INTO ls_tabrel.

      lv_from = |{ lv_from } { ls_tabrel-tabname1 } { ls_tabrel-rel_txt } { ls_tabrel-tabname2 } ON |.

      APPEND lv_from TO ct_string.

      CLEAR lv_from.

      lcl_app=&gt;ret_join_from_str(
        EXPORTING
          iv_tab1    = ls_tabrel-tabname1
          iv_tab2    = ls_tabrel-tabname2
          it_joinfld = lt_joinfld
        CHANGING
          ct_string  = ct_string
        ).

    ENDLOOP.

  ELSE.

    READ TABLE t_sqlfld INTO ls_sqlfld INDEX 1.
    IF syst-subrc &lt;&gt; 0.

      RETURN.

    ENDIF.
    lv_from = |{ lv_from } { ls_sqlfld-tabname }|.

    APPEND lv_from TO ct_string.

  ENDIF.

ENDMETHOD.                    &quot;ret_from
METHOD ret_join_from_str.

  DATA:
    ls_joinfld  TYPE ty_joinfld.

  DATA:
    lv_keymatch TYPE abap_bool,
    lv_from     TYPE string,
    lv_tabix    TYPE sytabix,
    lv_exit     TYPE abap_bool.


  READ TABLE it_joinfld TRANSPORTING NO FIELDS WITH KEY tab1 = iv_tab1
                                                        tab2 = iv_tab2
                                                        BINARY SEARCH.

  IF syst-subrc &lt;&gt; 0.

    RETURN.

  ENDIF.

  lv_tabix = syst-tabix.

  LOOP AT it_joinfld INTO ls_joinfld FROM lv_tabix.

    lcl_app=&gt;chk_ext_joinfld_loop( EXPORTING is_joinfld  = ls_joinfld
                                             iv_tab1     = iv_tab1
                                             iv_tab2     = iv_tab2
                                   IMPORTING ev_exit     = lv_exit
                                    CHANGING cv_keymatch = lv_keymatch
                                 ).

    IF lv_exit = abap_true.
      EXIT.
    ENDIF.

    lv_from = |         { lv_from } { ls_joinfld-tab1 }~{ ls_joinfld-fldname } = { ls_joinfld-tab2 }~{ ls_joinfld-fldname } |.

    APPEND lv_from TO ct_string.

    lv_from = &apos;AND&apos;.

  ENDLOOP.

ENDMETHOD.                    &quot;ret_join_from
METHOD chk_ext_joinfld_loop.

  CHECK is_joinfld-fldname &lt;&gt; &apos;MANDT&apos;.


  IF is_joinfld-tab1  &lt;&gt; iv_tab1
  OR is_joinfld-tab2  &lt;&gt; iv_tab2.

    ev_exit = abap_true.

  ENDIF.

* ys were found for Inner join?
  IF is_joinfld-key = &apos;X&apos;
  OR is_joinfld-key2 = &apos;X&apos;.

    cv_keymatch = abap_true.

  ENDIF.

* ys    ere found and no more keys left, Get out.
  IF  cv_keymatch = abap_true
  AND is_joinfld-key  &lt;&gt; &apos;X&apos;
  AND is_joinfld-key2 &lt;&gt; &apos;X&apos;.

    ev_exit = abap_true.

  ENDIF.

ENDMETHOD.                    &quot;chk_ext_joinfld_loop

METHOD ret_whr.

  DATA:
    ls_fld      TYPE rsdsfields.

  FIELD-SYMBOLS:
    &lt;lfs_whr&gt;   TYPE rsdswhere,
    &lt;lfs_whr1&gt;  TYPE rsds_where.

  DATA:
    lv_reg      TYPE string,
    lv_rep      TYPE string.

  CHECK iv_join = abap_true.

  SORT ct_whr BY tablename.

  LOOP AT it_fld INTO ls_fld.

    READ TABLE ct_whr ASSIGNING &lt;lfs_whr1&gt;
                       WITH KEY tablename = ls_fld-tablename
                                BINARY SEARCH.

    CHECK syst-subrc IS INITIAL.

    LOOP AT &lt;lfs_whr1&gt;-where_tab ASSIGNING &lt;lfs_whr&gt; .

      lv_reg = &apos;\b&apos; &amp;&amp; ls_fld-fieldname &amp;&amp; &apos;\b&apos;.

      lv_rep = ls_fld-tablename &amp;&amp; &apos;~&apos; &amp;&amp; ls_fld-fieldname.

      &lt;lfs_whr&gt;-line = replace( val   = &lt;lfs_whr&gt;-line
                                regex = lv_reg
                                with  = lv_rep ).

    ENDLOOP.

  ENDLOOP.

ENDMETHOD.                    &quot;ret_whr
METHOD prep_query.

  DATA:
    lt_where   TYPE rsds_twhere      .

  DATA:
    lv_txt  TYPE string,
    lv_join TYPE abap_bool   .

  DATA:
    ls_where    TYPE rsds_where,
    ls_whr_data TYPE rsdswhere   .

  IF t_tabrel IS NOT INITIAL.
    lv_join = abap_true.
  ENDIF.

  rt_string = lcl_app=&gt;get_sel_string( lv_join ).

  lcl_app=&gt;ret_from(  EXPORTING iv_join  = lv_join
                      CHANGING ct_string = rt_string
                    ).

  IF it_whr IS  INITIAL
  OR it_fld IS  INITIAL.
    RETURN.
  ENDIF.

  lt_where = it_whr.
  lcl_app=&gt;ret_whr( EXPORTING iv_join  = lv_join
                              it_fld   = it_fld
                    CHANGING  ct_whr   = lt_where ).

  lv_txt = &apos;WHERE&apos;.
*  APPEND lv_txt TO rt_string.
  LOOP AT lt_where INTO ls_where.

    LOOP AT ls_where-where_tab INTO ls_whr_data.

      CONDENSE ls_whr_data-line.
      lv_txt = |{ lv_txt } { ls_whr_data-line }|.
*      APPEND ls_whr_data-line TO rt_string.
      APPEND lv_txt TO rt_string.
      CLEAR lv_txt.
    ENDLOOP.
    lv_txt = &apos;AND&apos;.
  ENDLOOP.


ENDMETHOD.                    &quot;prep_query
METHOD fld_sel_popup.

  TYPES:
    BEGIN OF lty_fieldtab,
      tf TYPE dd03p,
      mark TYPE char1,
    END OF lty_fieldtab.

  DATA :
    lt_tabfields TYPE STANDARD TABLE OF lty_fieldtab.

  DATA :
    ls_tabfields TYPE lty_fieldtab,
    ls_data      TYPE ty_dd03vt,
    ls_fields    TYPE ty_sqlfields.

  CHECK it_data IS NOT INITIAL.

  LOOP AT it_data INTO ls_data.
    ls_tabfields-tf-fieldname = ls_data-fieldname.
    ls_tabfields-tf-tabname  = ls_data-tabname.
    ls_tabfields-tf-rollname = ls_data-rollname.
    ls_tabfields-tf-ddtext   = ls_data-ddtext.

    READ TABLE ct_fields TRANSPORTING NO FIELDS
                                       WITH KEY tabname = ls_data-tabname
                                                fieldname = ls_data-fieldname.
    IF  syst-subrc IS INITIAL.

      ls_tabfields-mark  = &apos;X&apos;.
    ELSE.
      CLEAR ls_tabfields-mark.
    ENDIF.

    APPEND ls_tabfields TO lt_tabfields.

  ENDLOOP.

  CALL FUNCTION &apos;DD_LIST_TABFIELDS&apos;
    TABLES
      fieldtab = lt_tabfields
    EXCEPTIONS
      OTHERS   = 2.

  IF sy-subrc &lt;&gt; 0.

    RETURN.

  ENDIF.

  DELETE lt_tabfields WHERE mark IS INITIAL.

*     EFRESH ct_fields.
  DELETE ct_fields WHERE tabname = ls_tabfields-tf-tabname.

  LOOP AT lt_tabfields INTO ls_tabfields.
    ls_fields-fieldname = ls_tabfields-tf-fieldname.
    ls_fields-tabname   = ls_tabfields-tf-tabname.
    ls_fields-ddtext  = ls_tabfields-tf-ddtext.
    APPEND ls_fields TO ct_fields.

  ENDLOOP.

ENDMETHOD.                    &quot;Field_select
METHOD get_tabfields.

**&lt; Main Logic &gt;&gt;&gt;

  SELECT  tabname
          fieldname
          position
          rollname
          checktable
          ddtext
          FROM  dd03vt
          INTO TABLE et_data
          WHERE tabname    = iv_tabname
          AND as4local   = &apos;A&apos;
          AND ddlanguage = &apos;E&apos;.

  IF syst-subrc &lt;&gt; 0.

    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;No Data found for Input Table&apos;.
  ENDIF.
* ll salv
  SORT et_data BY position ASCENDING.



ENDMETHOD.                    &quot;get_tabfields
METHOD ret_tabname.

**ariable **
  DATA:
    lv_ret     TYPE char1.
**Work Area**
  DATA:
    ls_fields  TYPE sval.

* Internal Table*
  DATA:
    lt_fields  TYPE STANDARD TABLE OF sval.

**&lt; Main Logic &gt;&gt;&gt;

  ls_fields-tabname   = &apos;DD03VT&apos;.
  ls_fields-fieldname = &apos;TABNAME&apos;.
  ls_fields-field_obl = &apos;X&apos;.

  APPEND ls_fields TO lt_fields.

  CALL FUNCTION &apos;POPUP_GET_VALUES_DB_CHECKED&apos;
    EXPORTING
      check_existence = &apos;X&apos;
      popup_title     = &apos;Input Table Name&apos;
    IMPORTING
      returncode      = lv_ret
    TABLES
      fields          = lt_fields
    EXCEPTIONS
      error_in_fields = 1
      OTHERS          = 2.
* eck Error*
  IF sy-subrc &lt;&gt; 0
  OR lv_ret IS NOT INITIAL.

    MESSAGE s000(db) WITH &apos;Incorrect Table Name&apos;.

  ELSE.

    READ TABLE lt_fields INTO ls_fields INDEX 1.

    IF syst-subrc IS INITIAL.
      rv_tabname = ls_fields-value.
    ENDIF.

  ENDIF.


ENDMETHOD.                    &quot;ret_tabname
METHOD push_list.

  DATA :
    ls_list   TYPE ty_list.

  ls_list-ref = iv_ref.

  APPEND ls_list TO t_list.

ENDMETHOD.                    &quot;push_list

METHOD modif_list.

  DATA :
    ls_list   TYPE ty_list.

  ls_list-ref = iv_ref.

  MODIFY t_list FROM ls_list INDEX iv_index.

ENDMETHOD.                    &quot;modif_list

METHOD read_list.
  DATA:
    ls_list TYPE ty_list.

  READ TABLE t_list INTO ls_list INDEX iv_index.

  IF syst-subrc IS INITIAL.

    rv_ref = ls_list-ref.

  ENDIF.

ENDMETHOD.                    &quot;pop_list
METHOD pop_list .

  DELETE t_list INDEX iv_index.

ENDMETHOD.                    &quot;del_list
METHOD chk_limit.

  IF lines( t_list ) &gt;= 30.
    MESSAGE &apos;You cannot open more than 30 tabs&apos;(m64)
    TYPE &apos;E&apos;.&quot; DISPLAY LIKE &apos;E&apos;.
    RETURN.
  ENDIF.

ENDMETHOD.                    &quot;chk_limit
METHOD qtab_to_string.
  DATA :
    lt_query         TYPE soli_tab.
  DATA:
    ls_query         TYPE soli,
    ls_find_comment  TYPE match_result.

  lt_query = it_query.

  LOOP AT lt_query INTO ls_query.

    IF iv_com = abap_false.
      CONDENSE ls_query-line.
      CHECK ls_query IS NOT INITIAL
        AND ls_query-line+0(1) &lt;&gt; &apos;*&apos;
        AND ls_query-line+0(1) &lt;&gt; &apos;&quot;&apos;.



      FIND FIRST OCCURRENCE OF &apos;&quot;&apos;
                            IN ls_query-line
                       RESULTS ls_find_comment IGNORING CASE.

      IF sy-subrc = 0.
        ls_query-line = ls_query-line+0(ls_find_comment-offset).
      ENDIF.

      SHIFT ls_query-line LEFT DELETING LEADING space.
    ENDIF.
    IF rv_query IS INITIAL.
      rv_query =  ls_query-line.
      CONTINUE.
    ENDIF.
    CONCATENATE rv_query ls_query-line INTO rv_query SEPARATED BY iv_sep.

  ENDLOOP.

ENDMETHOD.                    &quot;qtab_to_string
METHOD ret_query_comp.

  DATA:
    ls_find_upto   TYPE match_result,
    ls_sub         TYPE submatch_result,
    ls_sql         TYPE sqls_stmt_t.

  DATA:
    lo_regex       TYPE REF TO cl_abap_regex.

  DATA:
    lv_query       TYPE string.


  lv_query = iv_query.

  lv_query = replace(
               val   = lv_query
               sub   = &apos;.&apos;
               occ   = -1
               with  = space
               ).

  CREATE OBJECT lo_regex
    EXPORTING
      pattern     = &apos;UP TO ([0-9]+) ROWS&apos;
      ignore_case = abap_true.

  FIND FIRST OCCURRENCE OF REGEX lo_regex
                              IN lv_query
                         RESULTS ls_find_upto.
  IF sy-subrc = 0.
    READ TABLE ls_find_upto-submatches INTO ls_sub INDEX 1.
    IF sy-subrc = 0.
      ev_upto = lv_query+ls_sub-offset(ls_sub-length).
    ENDIF.

    REPLACE FIRST OCCURRENCE OF REGEX lo_regex
                                   IN lv_query WITH &apos;&apos;.

  ENDIF.

  CALL FUNCTION &apos;DB_SQL_PARSE&apos;
    EXPORTING
      stmt_str = lv_query
    IMPORTING
      sql_stmt = ls_sql.

  IF ls_sql-operation &lt;&gt; &apos;SELECT&apos;.

    MESSAGE e000(db) WITH &apos;ERROR in Query&apos;.

  ENDIF.

  ev_select = lv_query+ls_sql-select_list-off(ls_sql-select_list-len).
  ev_where  = lv_query+ls_sql-where_clause-off(ls_sql-where_clause-len).
  ev_from   = lv_query+ls_sql-table_clause-off(ls_sql-table_clause-len).
  ev_order  = lv_query+ls_sql-order_by_clause-off(ls_sql-order_by_clause-len).
  ev_group  = lv_query+ls_sql-group_by_clause-off(ls_sql-group_by_clause-len).

ENDMETHOD.                    &quot;ret_query_comp
METHOD ret_tab_comp.

  DATA:
    lo_type     TYPE REF TO cl_abap_typedescr,
    lo_struc    TYPE REF TO cl_abap_structdescr.

  DATA:
    lt_comps    TYPE abap_component_view_tab.

  DATA:
    ls_comps    TYPE abap_simple_componentdescr,
    ls_comp     TYPE abap_componentdescr.

  cl_abap_structdescr=&gt;describe_by_name(  EXPORTING    p_name         = iv_name    &quot; Type name
                                          RECEIVING    p_descr_ref    = lo_type    &quot; Reference to description object
                                          EXCEPTIONS   OTHERS         = 2
                                       ).

  IF sy-subrc &lt;&gt; 0.
    RETURN.
  ENDIF.

  lo_struc ?= lo_type.

  rt_comp =  lo_struc-&gt;get_components( ).

  READ TABLE rt_comp TRANSPORTING NO FIELDS WITH KEY as_include = &apos;X&apos;.

  IF syst-subrc IS INITIAL.

    REFRESH rt_comp.

    lt_comps =   lo_struc-&gt;get_included_view(  ).

    LOOP AT lt_comps INTO ls_comps.

      ls_comp-name = ls_comps-name.
      ls_comp-type = ls_comps-type.
      APPEND ls_comp TO rt_comp.

    ENDLOOP.
  ENDIF.
ENDMETHOD.                    &quot;ret_tab_comp
METHOD chk_all_wid_join.

  IF  iv_from CS &apos;JOIN&apos;
  AND iv_select CS &apos;*&apos;.
    MESSAGE e000(db) WITH &apos;* not possible with join&apos;.
  ENDIF.

ENDMETHOD.                    &quot;chk_all_wid_join
METHOD ret_from_tabref.

  DATA:
    ls_from        TYPE string.

  DATA:
    lt_from_tab    TYPE string_table.

  DATA:
    lv_tabname     TYPE tabname.

  SPLIT iv_from   AT space
          INTO TABLE lt_from_tab.

  LOOP AT lt_from_tab INTO ls_from.

    TRANSLATE ls_from TO UPPER CASE.
    TRANSLATE ls_from USING &apos;. &apos;.
    CONDENSE ls_from.

    CASE ls_from.

      WHEN &apos;INNER&apos;
        OR &apos;JOIN&apos;
        OR &apos;OUTER&apos;
        OR &apos;ON&apos;
        OR &apos;=&apos;
        OR &apos;~&apos;
        OR space.

        CONTINUE.

    ENDCASE.

    TRY.

        lv_tabname = ls_from.

        lcl_app=&gt;chk_tabnm_empt_vald( lv_tabname ).

        IF  iv_select CS &apos;*&apos;
        AND iv_select NS &apos;(*)&apos;.

          APPEND LINES OF lcl_app=&gt;get_type_comp( ls_from ) TO ev_tab1.
        ELSE.
          APPEND LINES OF lcl_app=&gt;ret_tab_comp( ls_from ) TO ev_tab.

        ENDIF.

      CATCH lcl_error.

    ENDTRY.  &quot;




  ENDLOOP.

ENDMETHOD.                    &quot;ret_from_tabref
METHOD ret_query_tabref.

  DATA:
    lt_fields      TYPE string_table.

  DATA:
    ls_fields      TYPE string.

  DATA:
    lo_comp_tab1   TYPE cl_abap_structdescr=&gt;component_table,
    lo_comp_tab    TYPE cl_abap_structdescr=&gt;component_table.
*
  DATA:
    ls_comp_tab    TYPE abap_componentdescr.

  DATA:
    lv_skip        TYPE abap_bool.

  DATA:
    lo_new_tab  TYPE REF TO cl_abap_tabledescr.

  REFRESH:
    et_fields[].

  SPLIT iv_select AT space
          INTO TABLE lt_fields.

  lcl_app=&gt;chk_all_wid_join(
    iv_select = iv_select
    iv_from   = iv_from
    ).

  lcl_app=&gt;ret_from_tabref(
    EXPORTING
      iv_select = iv_select
      iv_from   = iv_from
    IMPORTING
      ev_tab    = lo_comp_tab
      ev_tab1   = lo_comp_tab1
    ).


  LOOP AT lt_fields INTO ls_fields.

    TRANSLATE ls_fields TO UPPER CASE.

    lcl_app=&gt;ret_fld(
      EXPORTING
        iv_fld  = ls_fields
        tab1    = lo_comp_tab
        tab2    = lo_comp_tab1
      IMPORTING
        ev_skip = lv_skip
        es_tab  = ls_comp_tab
      ).

    CHECK lv_skip  = abap_false.

    APPEND ls_comp_tab TO lo_comp_tab1.
    APPEND ls_fields TO et_fields.

  ENDLOOP.

  IF lo_comp_tab1 IS INITIAL.

    RETURN.

  ENDIF.
* eate New Dynamic Table Structure Handle .
  TRY.
      lo_new_tab = cl_abap_tabledescr=&gt;create(
                     p_line_type  = cl_abap_structdescr=&gt;create( lo_comp_tab1 )    &quot; Line Type
                     p_table_kind = cl_abap_tabledescr=&gt;tablekind_std    &quot; Table Type (STANDARD, SORTED, HASHED)
                     p_unique     = abap_false    &quot; Uniqueness of the Key
                     ).

* eate Table Refernece for the new Structure.
      CREATE DATA rt_data TYPE HANDLE lo_new_tab.

    CATCH
      cx_sy_table_creation
      cx_sy_create_data_error.    &quot; Exception when Creating a Table Type

      RETURN.
  ENDTRY.

ENDMETHOD.                    &quot;ret_query_tabref
METHOD ret_fld.
  DATA:
    lv_tab   TYPE tabname,
    lv_fld   TYPE fieldname,
    lv_fldnm TYPE fieldname.

  SPLIT iv_fld AT &apos;~&apos;
             INTO lv_tab
                  lv_fld.

  IF lv_fld IS INITIAL.

    lv_fld = lv_tab.
    CLEAR lv_tab.

  ENDIF.

  lv_fldnm = iv_fld.

  TRANSLATE lv_fldnm USING &apos;~_&apos;.

  IF lv_fldnm = &apos;COUNT(*)&apos;.
    es_tab-type ?= cl_abap_elemdescr=&gt;describe_by_name( &apos;I&apos; ).
    es_tab-name = &apos;COL_COUNT&apos;.
    RETURN.
  ENDIF.
* Exists in All component tab?
  READ TABLE tab1 INTO es_tab WITH KEY name = lv_fld.

  IF syst-subrc IS INITIAL.

* Already Passed to Component tab?
    READ TABLE tab2 TRANSPORTING NO FIELDS WITH KEY name = lv_fldnm.

    IF syst-subrc IS INITIAL.
      ev_skip = abap_true.
    ELSE.
      es_tab-name = lv_fldnm.
    ENDIF.

  ELSE.
    ev_skip = abap_true.
  ENDIF.

ENDMETHOD.                    &quot;ret_fld
METHOD exec_query_string.

  DATA:
    lt_fields      TYPE string_table.

  DATA:
    lv_select      TYPE string,
    lv_from        TYPE string,
    lv_where       TYPE string,
    lv_order       TYPE string,
    lv_group       TYPE string,
    lv_upto        TYPE i,
    lv_sel_len     TYPE i,
    lv_single      TYPE abap_bool,
    lv_distinct    TYPE abap_bool.

  lcl_app=&gt;ret_query_comp(
    EXPORTING
      iv_query  = iv_query
    IMPORTING
      ev_select = lv_select
      ev_from   = lv_from
      ev_where  = lv_where
      ev_upto   = lv_upto
      ev_order  = lv_order
      ev_group  = lv_group
      ).

  IF lv_from IS INITIAL.

    RETURN.

  ENDIF.

  IF lv_upto IS INITIAL.
    lv_upto = iv_upto.
  ENDIF.

  TRANSLATE lv_select TO UPPER CASE.
  CONDENSE lv_select.

  lv_sel_len  = strlen( lv_select ).

  IF lv_sel_len &gt; 7.

    IF lv_select(6) = &apos;SINGLE&apos; .

      lv_single = abap_true.
      lv_sel_len = lv_sel_len - 6.
      lv_select = lv_select+6(lv_sel_len).

    ELSEIF lv_select(8) = &apos;DISTINCT&apos; .

      lv_distinct = abap_true.
      lv_sel_len = lv_sel_len - 8.
      lv_select = lv_select+8(lv_sel_len).

    ENDIF.
  ENDIF.

  CONDENSE lv_select.

  lcl_app=&gt;ret_query_tabref(
    EXPORTING
      iv_select = lv_select
      iv_from   = lv_from
    IMPORTING
      rt_data   = rt_data
      et_fields = lt_fields
    ).

  DELETE lt_fields WHERE table_line IS INITIAL.

  lcl_app=&gt;exec_select(
    EXPORTING
      iv_single   = lv_single
      iv_distinct = lv_distinct
      it_fields   = lt_fields
      iv_from     = lv_from
      iv_where    = lv_where
      iv_upto     = lv_upto
      iv_group    = lv_group
      iv_order    = lv_order
    CHANGING
      co_ref      = rt_data
    ).

ENDMETHOD.                    &quot;exec_query_string
METHOD exec_select.

  FIELD-SYMBOLS:
    &lt;lft_data&gt; TYPE STANDARD TABLE,
    &lt;lfs_data&gt; TYPE any.

  DATA :
    lo_root   TYPE REF TO cx_root.

  DATA :
    lv_msg    TYPE string.

**ereference it to Global table Field symbol
  ASSIGN co_ref-&gt;* TO &lt;lft_data&gt;.

  IF &lt;lft_data&gt; IS NOT ASSIGNED.
    RETURN.
  ENDIF.

  TRY.
      CASE abap_true.

        WHEN iv_single.
          APPEND INITIAL LINE TO &lt;lft_data&gt; ASSIGNING &lt;lfs_data&gt;.

          SELECT SINGLE (it_fields)&quot;(lv_select)&quot;(lt_fields)
                   FROM (iv_from)
                   INTO &lt;lfs_data&gt;
                  WHERE (iv_where)
               GROUP BY (iv_group)
*               ORDER BY (iv_order)
          .

        WHEN iv_distinct.

          SELECT DISTINCT (it_fields)&quot;(lv_select)&quot;(lt_fields)
                     FROM (iv_from)
                    UP TO iv_upto ROWS
               INTO TABLE &lt;lft_data&gt;
                    WHERE (iv_where)
                 GROUP BY (iv_group)
                 ORDER BY (iv_order)
          .

        WHEN OTHERS.
          &quot;&quot;&quot;&quot;Future&quot;&quot;&quot;
          &quot;&quot; Check If join is requested
          &quot;&quot; Check if one of the table is Pooled/cluster..
          &quot;&quot; Break it_fields and iv_from and iv_where into Table based fields.
          &quot;&quot; run simple query on first table..
          &quot; run for all entry on depandent table..
          &quot; loop at first data tab and loop on second to add matching entries( for inner join) all for outer,
          &quot; repeat two and three for next table if possible..
          &quot;chek one of them is cluster.

*****          IF abap_true = lcl_app=&gt;from_has_cluster_table( iv_from )
*****            AND iv_from CS &apos;JOIN&apos;.
*****            DATA:
*****              lt_tablist TYPE STANDARD TABLE OF tabname,
*****              lt_tabfields TYPE tty_tabfield.
*****
*****            DATA:
*****              ls_tablist TYPE tabname.
*****            DATA:
*****              ls_tabfields TYPE ty_tabfield.
*****            DATA:
*****              lt_fields TYPE string_table.
*****
*****            FIELD-SYMBOLS:&lt;tab1&gt; TYPE STANDARD TABLE .
*****            FIELD-SYMBOLS:&lt;tab2&gt; TYPE STANDARD TABLE .
*****
*****            lt_tablist = lcl_app=&gt;ret_tabs_of_from( iv_from ).
*****
*****
*****            lt_tabfields = lcl_app=&gt;ret_tabfields_from_fields( it_fields ).
*****            APPEND LINES OF lcl_app=&gt;ret_tabfields_of_from( iv_from ) TO lt_tabfields.
*****            DELETE lt_tabfields WHERE tabname IS INITIAL OR fieldname IS INITIAL.
*****            SORT lt_tabfields BY tabname fieldname.
*****            DELETE ADJACENT DUPLICATES FROM lt_tabfields COMPARING ALL FIELDS.
*****            DATA lo_ref TYPE REF TO data.
*****            DATA lo_ref1 TYPE REF TO data.
*****            DATA lv_select TYPE string.
*****            DATA lt_fld_tmp TYPE string_table.
*****            DATA lv_string1 TYPE string.
*****            DATA lv_whr TYPE string.
*****            LOOP AT lt_tablist INTO ls_tablist.
*****              CLEAR lt_fld_tmp.
*****              lv_select = &apos;SELECT&apos;.
*****              LOOP AT lt_tabfields INTO ls_tabfields WHERE tabname = ls_tablist.
*****                lv_select = |{ lv_select } { ls_tabfields-fieldname }|.
*****                APPEND ls_tabfields-fieldname TO lt_fld_tmp.
*****              ENDLOOP.
******                CONDENSE lv_select.
*****              lv_string1 = ls_tablist.
*****              IF syst-tabix = 1.
*****                lcl_app=&gt;ret_query_tabref( EXPORTING iv_select = lv_select
*****                                                     iv_from   = lv_string1
*****                                           IMPORTING rt_data   = lo_ref
*****                                          ).
*****
*****                ASSIGN lo_ref-&gt;* TO &lt;tab1&gt;.
*****                SELECT (lt_fld_tmp)&quot;(lv_select)&quot;(lt_fields)
*****                  FROM (ls_tablist)
*****                  UP TO iv_upto ROWS
*****                  INTO TABLE &lt;tab1&gt;.
*****
*****              ELSE.
*****                lcl_app=&gt;ret_query_tabref( EXPORTING iv_select = lv_select
*****                               iv_from   = lv_string1
*****                     IMPORTING rt_data   = lo_ref1
*****                    ).
*****
*****                ASSIGN lo_ref1-&gt;* TO &lt;tab2&gt;.
*****
*****                DATA:
*****                   ls_from        TYPE string.
*****
*****                DATA:
*****                  lt_from_tab    TYPE string_table.
*****
*****                DATA:
*****                  lv_tabname     TYPE tabname.
******  DATA:
******    ls_tabfields TYPE ty_Tabfield.
*****                SPLIT iv_from   AT &apos; on &apos;
*****                        INTO TABLE lt_from_tab.
*****
*****                LOOP AT lt_from_tab INTO ls_from.
*****
*****                  TRANSLATE ls_from TO UPPER CASE.
*****                  TRANSLATE ls_from USING &apos;. &apos;.
*****                  CONDENSE ls_from.
*****
*****                  CASE ls_from.
*****
*****                    WHEN &apos;INNER&apos;
*****                      OR &apos;JOIN&apos;
*****                      OR &apos;OUTER&apos;
*****                      OR &apos;ON&apos;
*****                      OR &apos;=&apos;
******        OR &apos;~&apos;
*****                      OR space.
*****
*****                      CONTINUE.
*****
*****                  ENDCASE.
*****
*****                  IF ls_from CS &apos;=&apos;
*****                    AND ls_from CS ls_tablist.
*****                    READ TABLE lt_tablist INTO lv_tabname INDEX 1.
*****                    TRANSLATE ls_from TO UPPER CASE.
*****                    REPLACE ALL OCCURRENCES OF lv_tabname IN ls_from WITH &apos;&lt;tab1&gt;-&apos;.
*****                    REPLACE ALL OCCURRENCES OF ls_tablist IN ls_from WITH space.
*****                    REPLACE ALL OCCURRENCES OF &apos;~&apos; IN ls_from WITH space.
*****
******      REPLACE ls_tablist WITH &apos;&lt;tab1&gt;&apos; into ls_From.
*****                    EXIT.
******      SPLIT ls_from at &apos;~&apos;
******                  into ls_tabfields-tabname
******                       ls_tabfields-fieldname.
*****
*****                  ENDIF.
*****
*****                ENDLOOP.
*****
*****                SELECT (lt_fld_tmp)&quot;(lv_select)&quot;(lt_fields)
*****                  FROM (ls_tablist)
*****                  UP TO iv_upto ROWS
*****                  INTO TABLE &lt;tab2&gt;
*****                  FOR ALL ENTRIES IN &lt;tab1&gt;
*****                  WHERE (ls_from)
*****                  .
*****
*****              ENDIF.
*****            ENDLOOP.
*****
*****            RETURN.
*****
*****          ENDIF.

          SELECT (it_fields)&quot;(lv_select)&quot;(lt_fields)
            FROM (iv_from)
           UP TO iv_upto ROWS
            INTO TABLE &lt;lft_data&gt;
           WHERE (iv_where)
        GROUP BY (iv_group)
        ORDER BY (iv_order)
          .

      ENDCASE.
      &quot;&quot;&quot;auth check s_tabu_lin   check..
      IF syst-subrc &lt;&gt; 0.
        MESSAGE e000(db) WITH &apos;Error fetching data&apos;.
      ENDIF.

    CATCH cx_sy_dynamic_osql_syntax
          cx_sy_dynamic_osql_semantics
          cx_sy_open_sql_db
     INTO lo_root.

      lv_msg = lo_root-&gt;get_text( ).
      MESSAGE e000(db) WITH lv_msg.

  ENDTRY.
  DATA lv_msg1 TYPE char255.
  lv_msg1 = |{ lines( &lt;lft_data&gt; ) } rows fetched|.
  MESSAGE s000(db) WITH lv_msg1.

ENDMETHOD.                    &quot;exec_select
METHOD ret_tabfields_of_from.
  DATA:
    ls_from        TYPE string.

  DATA:
    lt_from_tab    TYPE string_table.

  DATA:
    lv_tabname     TYPE tabname.
  DATA:
    ls_tabfields TYPE ty_tabfield.
  SPLIT iv_from   AT space
          INTO TABLE lt_from_tab.

  LOOP AT lt_from_tab INTO ls_from.

    TRANSLATE ls_from TO UPPER CASE.
    TRANSLATE ls_from USING &apos;. &apos;.
    CONDENSE ls_from.

    CASE ls_from.

      WHEN &apos;INNER&apos;
        OR &apos;JOIN&apos;
        OR &apos;OUTER&apos;
        OR &apos;ON&apos;
        OR &apos;=&apos;
*        OR &apos;~&apos;
        OR space.

        CONTINUE.

    ENDCASE.

    IF ls_from CS &apos;~&apos;.
      SPLIT ls_from AT &apos;~&apos;
                  INTO ls_tabfields-tabname
                       ls_tabfields-fieldname.
      APPEND ls_tabfields TO rt_tabfields.
    ENDIF.
  ENDLOOP.
ENDMETHOD.                    &quot;ret_tabfields_of_from
METHOD ret_tabfields_from_fields.
  DATA:
    ls_tabfields TYPE ty_tabfield.
  DATA:
    lv_string  TYPE string,
    lv_tab     TYPE tabname,
    lv_fld     TYPE fieldname.

  LOOP AT it_fields INTO lv_string.
    SPLIT lv_string  AT &apos;~&apos;
                   INTO lv_tab
                        lv_fld.

    ls_tabfields-tabname = lv_tab.
    ls_tabfields-fieldname = lv_fld.
    APPEND ls_tabfields TO rt_tabfields.
  ENDLOOP.

ENDMETHOD.                    &quot;ret_tabfields_from_fields
METHOD ret_tabs_of_from.
  DATA:
    ls_from        TYPE string.

  DATA:
    lt_from_tab    TYPE string_table.

  DATA:
    lv_tabname     TYPE tabname.

  SPLIT iv_from   AT space
          INTO TABLE lt_from_tab.

  LOOP AT lt_from_tab INTO ls_from.

    TRANSLATE ls_from TO UPPER CASE.
    TRANSLATE ls_from USING &apos;. &apos;.
    CONDENSE ls_from.

    CASE ls_from.

      WHEN &apos;INNER&apos;
        OR &apos;JOIN&apos;
        OR &apos;OUTER&apos;
        OR &apos;ON&apos;
        OR &apos;=&apos;
        OR &apos;~&apos;
        OR space.

        CONTINUE.

    ENDCASE.

    TRY.

        lv_tabname = ls_from.

        lcl_app=&gt;chk_tabnm_empt_vald( lv_tabname ).

        APPEND lv_tabname TO rt_tablist.

      CATCH lcl_error.

    ENDTRY.  &quot;

  ENDLOOP.

ENDMETHOD.                    &quot;ret_tabs_of_from
METHOD from_has_cluster_table.
  DATA:
    ls_from        TYPE string.

  DATA:
    lt_from_tab    TYPE string_table.

  DATA:
    lv_tabname     TYPE tabname.

  SPLIT iv_from   AT space
          INTO TABLE lt_from_tab.

  LOOP AT lt_from_tab INTO ls_from.

    TRANSLATE ls_from TO UPPER CASE.
    TRANSLATE ls_from USING &apos;. &apos;.
    CONDENSE ls_from.

    CASE ls_from.

      WHEN &apos;INNER&apos;
        OR &apos;JOIN&apos;
        OR &apos;OUTER&apos;
        OR &apos;ON&apos;
        OR &apos;=&apos;
        OR &apos;~&apos;
        OR space.

        CONTINUE.

    ENDCASE.

    TRY.

        lv_tabname = ls_from.

*        lcl_app=&gt;chk_tabnm_empt_vald( lv_tabname ).
        IF  abap_true = lcl_app=&gt;is_cluster_tab( lv_tabname ).
          rv_yes = abap_true.
          RETURN.

        ENDIF.
      CATCH lcl_error.

    ENDTRY.  &quot;

  ENDLOOP.
ENDMETHOD.                    &quot;from_has_cluster_table
METHOD is_cluster_tab.

  SELECT COUNT(*)
             FROM dd02l
             UP TO 1 ROWS
             WHERE tabname = iv_name
               AND as4local = &apos;A&apos;
               AND tabclass = &apos;CLUSTER&apos;.

  IF syst-dbcnt = 1.
    rv_yes = abap_true.
  ENDIF.
ENDMETHOD.                    &quot;is_cluster_tab
METHOD exec_query.
  DATA: lv_query TYPE string.


  CHECK it_query IS NOT INITIAL.

  lv_query = lcl_app=&gt;qtab_to_string( it_query ).

  IF lv_query IS NOT INITIAL.

    rt_data = lcl_app=&gt;exec_query_string( iv_query = lv_query
                                          iv_upto  = iv_upto
                                      ).
  ENDIF.
ENDMETHOD.                    &quot;exec_query

ENDCLASS.                    &quot;lcl_app IMPLEMENTATION
*----------------------------------------------------------------------*
*       CLASS lcl_app_unittest DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_app_unittest DEFINITION FOR TESTING DURATION SHORT RISK LEVEL HARMLESS.

  PRIVATE SECTION.


    METHODS:
      str_2_range_normal_string FOR TESTING,
      str_2_range_blank_string FOR TESTING,
      str_2_range_extraspace_string FOR TESTING,
      str_2_range_frontspace_string FOR TESTING,
      str_2_range_endspace_string FOR TESTING.





ENDCLASS.                    &quot;lcl_app_unittest DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_app_unittest IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_app_unittest IMPLEMENTATION.


  METHOD str_2_range_normal_string.
    DATA:
      lt_range_act TYPE rsis_t_range,
      lt_range_exp TYPE rsis_t_range.
    DATA:
      lr_range TYPE rsis_s_range.

    lr_range-sign = &apos;I&apos;.
    lr_range-option = &apos;EQ&apos;.

    lr_range-low = &apos;TEST&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;123&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;BLIK&apos;.
    APPEND lr_range TO lt_range_exp.
*WRITE: &apos;test&apos;.
    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( &apos;TEST 123 BLIK&apos;  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

    CLEAR lt_range_exp.

    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( &apos; &apos;  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

    DATA: lv_blank_string TYPE string VALUE space.

    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( lv_blank_string  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;test_str_2_range
  METHOD str_2_range_blank_string.
    DATA:
      lt_range_act TYPE rsis_t_range,
      lt_range_exp TYPE rsis_t_range.
    DATA:
      lr_range TYPE rsis_s_range.

    DATA:
      lv_blank_string TYPE string VALUE space.

    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( lv_blank_string  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;test_str_2_range
  METHOD str_2_range_extraspace_string.
    DATA:
      lt_range_act TYPE rsis_t_range,
      lt_range_exp TYPE rsis_t_range.
    DATA:
      lr_range TYPE rsis_s_range.

    lr_range-sign = &apos;I&apos;.
    lr_range-option = &apos;EQ&apos;.

    lr_range-low = &apos;TEST&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;123&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;BLIK&apos;.
    APPEND lr_range TO lt_range_exp.

    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( &apos; TEST 123 BLIK &apos;  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;test_str_2_range
  METHOD str_2_range_frontspace_string.
    DATA:
      lt_range_act TYPE rsis_t_range,
      lt_range_exp TYPE rsis_t_range.
    DATA:
      lr_range TYPE rsis_s_range.

    lr_range-sign = &apos;I&apos;.
    lr_range-option = &apos;EQ&apos;.

    lr_range-low = &apos;TEST&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;123&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;BLIK&apos;.
    APPEND lr_range TO lt_range_exp.

    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( &apos; TEST 123 BLIK&apos;  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;test_str_2_range
  METHOD str_2_range_endspace_string.
    DATA:
      lt_range_act TYPE rsis_t_range,
      lt_range_exp TYPE rsis_t_range.
    DATA:
      lr_range TYPE rsis_s_range.

    lr_range-sign = &apos;I&apos;.
    lr_range-option = &apos;EQ&apos;.

    lr_range-low = &apos;TEST&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;123&apos;.
    APPEND lr_range TO lt_range_exp.
    lr_range-low = &apos;BLIK&apos;.
    APPEND lr_range TO lt_range_exp.

    cl_abap_unit_assert=&gt;assert_equals(
        exp                  = lt_range_exp    &quot; Data Object with Expected Type
        act                  = lcl_app=&gt;str_2_range( &apos;TEST 123 BLIK &apos;  )    &quot; Data Object with Current Value
        msg                  = &apos;String_2_range failed&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;test_str_2_range
ENDCLASS.                    &quot;lcl_app_unittest IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZQUERY_SCR" VARCL="X" SUBC="I" SECU="&amp;NBSP" LEVL="702" RSTAT="T" RMAND="101" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZRD_QUERY_SCR" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZRD_QUERY_TOP
*&amp;---------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZRD_QUERY_APP
*&amp;---------------------------------------------------------------------*

*----------------------------------------------------------------------*
*       CLASS lcl_drag_object DEFINITION
*----------------------------------------------------------------------*
*       Class to store object on drag &amp; drop from DDIC to sql editor
*----------------------------------------------------------------------*
CLASS lcl_drag_object DEFINITION FINAL.
  PUBLIC SECTION.
    DATA:
      fields TYPE soli_tab.
ENDCLASS.&quot;lcl_drag_object DEFINITION
CLASS lcl_scr_static_objects_helper DEFINITION FINAL.

  PUBLIC SECTION.

  class-METHODs:
    init_screen_objects  IMPORTING io_container TYPE REF TO cl_gui_custom_container.

ENDCLASS.

CLASS lcl_scr_static_objects_helper IMPLEMENTATION.

  METHOD init_screen_objects .

 CHECK io_container IS NOT INITIAL.
*  CHECK lcl_scr=&gt;o_container IS INITIAL.
* Create the custom container
*  CREATE OBJECT w-o_container
*    EXPORTING
*      container_name = &apos;CUSTCONT&apos;
*    EXCEPTIONS
*      others         = 6.
*
*  IF syst-subrc &lt;&gt; 0.
*
*    RETURN.
*
*  ENDIF.
*       Split to 3 Columns.
  CREATE OBJECT w-o_splitter
    EXPORTING
      parent  = io_container
      rows    = 1
      columns = 3
    EXCEPTIONS
      others  = 3.

  IF syst-subrc &lt;&gt; 0.

    RETURN.

  ENDIF.

*   Set Query Container.
  w-o_qcontainer = w-o_splitter-&gt;get_container( row       = 1
                                                column    = 2
                                               ).

*       ********************************************************************
*       &lt;DDIC Repository&gt;&gt;

*         Set DDIC Container
  w-o_container_ddic_full = w-o_splitter-&gt;get_container( row       = 1
                                                         column    = 3
                                                       ).

*       ***  toolbar on DDIC container
  CREATE OBJECT w-o_splitter_ddic_full
    EXPORTING
      i_r_container = w-o_container_ddic_full.

*       * DDIC tree container
  w-o_container_ddic = w-o_splitter_ddic_full-&gt;get_controlcontainer( ).

*         Initiate Toolbar
  lcl_app=&gt;init_ddic_toolbar( ).


*       ****************************************************************
*       &lt;Queepository&gt;&gt;
  w-o_container_qrep = w-o_splitter-&gt;get_container( row       = 1
                                                    column    = 1
                                                  ).

  lcl_app=&gt;v_repo_width = 20.

  lcl_app=&gt;set_ddic_repo_width( lcl_app=&gt;v_repo_width ).

  lcl_app=&gt;set_query_repo_width( lcl_app=&gt;v_repo_width ).


  ENDMETHOD.

ENDCLASS.
*----------------------------------------------------------------------*
*       CLASS lcl_scr DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_scr DEFINITION.

  PUBLIC SECTION.
    TYPES:
      BEGIN OF ty_local_vers,
        node_key             TYPE num6,
        txt(100)             TYPE c,
        query                TYPE string,
      END OF ty_local_vers.
    DATA:
      o_tree_ddic            TYPE REF TO cl_gui_column_tree,
      o_tree_qrep            TYPE REF TO cl_gui_simple_tree,
      o_dock                 TYPE REF TO cl_gui_docking_container,
      o_textedit             TYPE REF TO cl_gui_abapedit,
      o_alv                  TYPE REF TO cl_salv_table.
*    CLASS-DATA:
*      o_container            TYPE REF TO cl_gui_custom_container.

    CLASS-METHODS:
      init_screen_objects    IMPORTING io_container TYPE REF TO cl_gui_custom_container
                             RETURNING VALUE(ro_self)    TYPE REF TO lcl_scr.
* Public Methods.
    METHODS:
      constructor,

      handle_output          IMPORTING iv_dynnr          TYPE sydynnr,

      handle_ucomm           IMPORTING iv_ucomm          TYPE okcode
                             RETURNING value(er_app_ref)       TYPE REF TO lcl_scr.

*      set_custom_container   IMPORTING iv_custom_container TYPE cl_gui_custom_container               .

  PRIVATE SECTION.

    DATA:
      t_node_ddic            TYPE treev_ntab,
      t_item_ddic            TYPE STANDARD TABLE OF mtreeitm,
      t_node_qrep            TYPE tty_qrep_node,
      t_local_vers           TYPE STANDARD TABLE OF ty_local_vers.

    DATA:
      o_tab                  TYPE REF TO data.

    DATA:
      v_ddrop_hndl_tree      TYPE i,
      v_node_num(6)          TYPE n,
      v_qrep_num(6)          TYPE n,
      v_qovrwrt              TYPE boolean,
      v_editable             TYPE boolean VALUE abap_true.

    DATA:
      s_ztquery              TYPE ztquery.

    METHODS:
      hndl_ugroup_multi,

      hndl_vuser_multi,

      handle_qsave,

      init_save_query RAISING lcl_error,

      check_query ,

      exit_app,

      set_focus_on_editor,

      report_estimated_qrows,

      ddic_init,

      query_repo_init,

      editor_init,

      dock_init,

      leave_current_tab,

      handle_visibility      IMPORTING iv_ref            TYPE REF TO lcl_scr
                                       iv_vis            TYPE abap_bool,

      ret_tab_obj            IMPORTING iv_index          TYPE sytabix OPTIONAL
                       RETURNING value(app_ref)          TYPE REF TO lcl_scr,

      exec2pc,

      ret_tab_columns        EXPORTING et_header         TYPE tty_header
                              CHANGING ct_data           TYPE STANDARD TABLE,

      get_file_path    RETURNING value(rv_filepath)      TYPE string,

      exec2bg,

      gen_query,

      set_tab_visible,

      alv_disp,

      alv_set_columns        IMPORTING io_alv            TYPE REF TO cl_salv_table,

      alv_init                CHANGING it_data           TYPE ANY TABLE,

      execute,

      handle_dtoolbar_add    IMPORTING iv_val            TYPE pvarfield,

      is_tab_current_ddic_itm IMPORTING iv_tabname       TYPE tabname
                             RETURNING value(rv_yes)    TYPE abap_bool,

      add_new_ddic_tabfolder IMPORTING iv_tabname        TYPE tabname,

      add_new_ddic_nodeitm   IMPORTING is_ddic_fields    TYPE lcl_app=&gt;ty_ddic_fields
                                       iv_parent_node    TYPE tv_nodekey,

      itrative_ddic_srch     IMPORTING it_search         TYPE string_table
                                       it_node_key       TYPE tv_nodekeys
                             EXPORTING ev_exit           TYPE abap_bool
                              CHANGING cs_sval           TYPE sval
                               RAISING lcl_error,

      hnd_ddic_tbar_find       RAISING lcl_error,

      sel_node_post_srch     IMPORTING iv_ok             TYPE sysubrc
                                       iv_srch_line      TYPE i
                                       it_node_key       TYPE tv_nodekeys
                               RAISING lcl_error ,

      rfrsh_ddic_tree,

      scr_8000_output         RAISING  lcl_error,

      scr_9300_output         RAISING  lcl_error,

      hnd_ddic_inp             RAISING lcl_error,

      ddic_get_selfld        EXPORTING et_fld            TYPE rsdsfields_t
                              RAISING lcl_error,

      ddic_ret_selnode RETURNING value(rt_node_key)      TYPE treev_nks
                               RAISING lcl_error,

      get_whr_4_inp          IMPORTING it_fld            TYPE rsdsfields_t
                             EXPORTING et_query          TYPE soli_tab
                              CHANGING rsds_twhere       TYPE rsds_twhere,

      set_txt_at_cursor      IMPORTING it_query          TYPE soli_tab,

      set_txt_at_line        IMPORTING iv_line_start     TYPE i
                                       iv_pos_start      TYPE i
                                       iv_break          TYPE abap_bool OPTIONAL
                                       it_query          TYPE soli_tab,
      set_tab_title,

      load_repo,

      add_repo_local,

      fnd_add_tble           IMPORTING is_query          TYPE soli
                                       iv_pos_start      TYPE i,

      get_fld_frm_ddic_node  IMPORTING iv_node_key       TYPE tv_nodekey
                                       iv_relat_key      TYPE tv_nodekey
                       RETURNING value(rv_text)          TYPE string.

    METHODS:

      hnd_ddic_toolbar_clic   FOR EVENT function_selected OF cl_gui_toolbar
                              IMPORTING fcode,

      hnd_ddic_item_dblclick  FOR EVENT item_double_click OF cl_gui_column_tree
                              IMPORTING node_key,

      hnd_ddic_drag           FOR EVENT on_drag_multiple  OF cl_gui_column_tree
                              IMPORTING node_key_table
                                        drag_drop_object,

      hnd_editor_dblclk       FOR EVENT dblclick          OF cl_gui_abapedit,

      hnd_editor_drop         FOR EVENT on_drop           OF cl_gui_abapedit
                              IMPORTING line
                                        pos
                                        dragdrop_object,

      on_user_command         FOR EVENT added_function    OF cl_salv_events
                              IMPORTING e_salv_function,

* Handle context menu display on repository tree
      hnd_repo_context_menu   FOR EVENT node_context_menu_request  OF cl_gui_simple_tree
                              IMPORTING menu,
** Handle context menu clic on repository tree
      hnd_repo_context_menu_sel  FOR EVENT node_context_menu_select OF cl_gui_simple_tree
                                IMPORTING fcode,
** Handle Node double clic on repository tree
      hnd_repo_dblclick       FOR EVENT node_double_click OF cl_gui_simple_tree
                              IMPORTING node_key.
    .

ENDCLASS.                    &quot;lcl_app DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_app IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_scr IMPLEMENTATION.
*  METHOD set_custom_container.
*
*    me-&gt;o_cust_conatiner = io_custum_container.
*  ENDMETHOD.
  METHOD init_screen_objects.


  CREATE OBJECT ro_self.
  ENDMETHOD.
  METHOD hndl_vuser_multi.

    DATA:
      lrt_vuser      TYPE trgr_user_name.

    DATA:
      lr_vuser       TYPE trgs_user_name,
      ls_vuser_str   TYPE string,
      ls_restrict    TYPE rsoptions,
      ls_inp         TYPE rstabfield.

    ls_restrict-nb = &apos;X&apos;.
    ls_restrict-bt = &apos;X&apos;.
    ls_restrict-cp = &apos;X&apos;.
    ls_restrict-ge = &apos;X&apos;.
    ls_restrict-gt = &apos;X&apos;.
    ls_restrict-le = &apos;X&apos;.
    ls_restrict-lt = &apos;X&apos;.
    ls_restrict-nb = &apos;X&apos;.
    ls_restrict-ne = &apos;X&apos;.
    ls_restrict-np = &apos;X&apos;.

    IF w-vis_users IS NOT INITIAL.

      ls_vuser_str = me-&gt;s_ztquery-visibility_users.

      lrt_vuser = lcl_app=&gt;str_2_range( ls_vuser_str ).

      lr_vuser-low    = w-vis_users.

      IF lrt_vuser IS NOT INITIAL.

        MODIFY lrt_vuser FROM lr_vuser INDEX 1.

      ELSE.

        APPEND lr_vuser TO lrt_vuser.

      ENDIF.

    ENDIF.

    CLEAR me-&gt;s_ztquery-visibility_users.

    ls_inp-tablename = &apos;USR02&apos;.
    ls_inp-fieldname = &apos;BNAME&apos;.

    lcl_app=&gt;call_multisel( EXPORTING iv_excl_opt = ls_restrict
                                      iv_input    = ls_inp
                            CHANGING  ct_rettab   = lrt_vuser
                           ).

    IF lrt_vuser IS NOT INITIAL.

      LOOP AT lrt_vuser INTO lr_vuser.
        IF syst-tabix = 1.
          w-vis_users = lr_vuser-low.
        ENDIF.

        me-&gt;s_ztquery-visibility_users = |{ me-&gt;s_ztquery-visibility_users } { lr_vuser-low }|.
      ENDLOOP.

    ELSE.

      CLEAR w-vis_users.

    ENDIF.

    CONDENSE me-&gt;s_ztquery-visibility_users.

  ENDMETHOD.                    &quot;hndl_ugroup_multi
  METHOD hndl_ugroup_multi.

    DATA:
      lrt_ugroup     TYPE RANGE OF xuclass.

    DATA:
      ls_restrict    TYPE rsoptions,
      ls_inp         TYPE rstabfield,
      ls_ugrp_str    TYPE string,
      lr_ugroup      LIKE LINE OF lrt_ugroup.

    ls_restrict-nb = &apos;X&apos;.
    ls_restrict-bt = &apos;X&apos;.
    ls_restrict-cp = &apos;X&apos;.
    ls_restrict-ge = &apos;X&apos;.
    ls_restrict-gt = &apos;X&apos;.
    ls_restrict-le = &apos;X&apos;.
    ls_restrict-lt = &apos;X&apos;.
    ls_restrict-nb = &apos;X&apos;.
    ls_restrict-ne = &apos;X&apos;.
    ls_restrict-np = &apos;X&apos;.

    IF w-visibilitygrp IS NOT INITIAL.

      ls_ugrp_str = me-&gt;s_ztquery-visibility_group.

      lrt_ugroup = lcl_app=&gt;str_2_range( ls_ugrp_str  ).

      lr_ugroup-low = w-visibilitygrp.

      IF lrt_ugroup IS NOT INITIAL.

        MODIFY lrt_ugroup FROM lr_ugroup INDEX 1.

      ELSE.

        APPEND lr_ugroup TO lrt_ugroup.

      ENDIF.

    ENDIF.

    CLEAR me-&gt;s_ztquery-visibility_group.

    ls_inp-tablename = &apos;USR02&apos;.
    ls_inp-fieldname = &apos;CLASS&apos;.

    lcl_app=&gt;call_multisel( EXPORTING iv_excl_opt = ls_restrict
                                      iv_input    = ls_inp
                             CHANGING ct_rettab   = lrt_ugroup
                           ).

    IF lrt_ugroup IS NOT INITIAL.

      LOOP AT lrt_ugroup INTO lr_ugroup.
        IF syst-tabix = 1.
          w-visibilitygrp = lr_ugroup-low.
        ENDIF.
        me-&gt;s_ztquery-visibility_group = |{ me-&gt;s_ztquery-visibility_group } { lr_ugroup-low }|.
      ENDLOOP.

    ELSE.

      CLEAR:
        w-visibilitygrp.

    ENDIF.

    CONDENSE me-&gt;s_ztquery-visibility_group.

  ENDMETHOD.                    &quot;hndl_ugroup_multi
  METHOD hnd_editor_drop.

    DATA:
      lo_drag_object TYPE REF TO lcl_drag_object.

    lo_drag_object ?= dragdrop_object-&gt;object.

    IF lo_drag_object IS INITIAL
    OR lo_drag_object-&gt;fields IS INITIAL.
      RETURN.
    ENDIF.

* Paste fieldname to editor at drop position

    me-&gt;set_txt_at_line( iv_line_start = line
                         iv_pos_start  = pos
                         iv_break      = lcl_app=&gt;paste_break
                         it_query      = lo_drag_object-&gt;fields
                       ).

  ENDMETHOD.                    &quot;hnd_editor_drop
  METHOD hnd_editor_dblclk.

    DATA:
      lv_line_start  TYPE i,
      lv_pos_start   TYPE i.

    DATA:
      ls_query       TYPE soli.

    DATA:
      lt_query       TYPE soli_tab.

    me-&gt;o_textedit-&gt;get_selection_pos( IMPORTINg from_line              =  lv_line_start   &quot; line from which selection starts
                                                 from_pos               =  lv_pos_start   &quot; starting position of selection in line linefrom
                                      EXCEPTIONS OTHERS                 = 1
                                     ).

    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    me-&gt;o_textedit-&gt;get_text(
      IMPORTING
        table                  =  lt_query   &quot; document text
      EXCEPTIONS
        OTHERS                 = 3
        ).

    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    READ TABLE lt_query INTO ls_query INDEX lv_line_start.

    IF syst-subrc &lt;&gt; 0.

      RETURN.

    ENDIF.

    me-&gt;fnd_add_tble(
      is_query      = ls_query
      iv_pos_start  = lv_pos_start
      ).

  ENDMETHOD.                    &quot;hnd_editor_dblclk
  METHOD fnd_add_tble.

    DATA:
      lv_pos         TYPE i VALUE 1,
      lv_pos_end     TYPE i,
      lv_val         TYPE pvarfield .

    DATA:
      lt_string      TYPE string_table.

    DATA:
      ls_string      TYPE string.

    SPLIT is_query AT space INTO TABLE lt_string.

    LOOP AT lt_string INTO ls_string.

      lv_pos_end =  lv_pos + strlen( ls_string ).

      IF  lv_pos_end &gt;= iv_pos_start .

        lv_val = to_upper( ls_string ).

        me-&gt;handle_dtoolbar_add( lv_val ).

        EXIT.

      ELSE.

        lv_pos = lv_pos_end + 1.

      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    &quot;fnd_add_tble
  METHOD hnd_ddic_drag.
    DATA :
      lo_drag_object TYPE REF TO lcl_drag_object.

    DATA:
      ls_node_key    TYPE tv_nodekey,
      ls_node        TYPE treev_node.

    DATA:
      lv_text        TYPE string.

    CREATE OBJECT lo_drag_object.

    LOOP AT node_key_table INTO ls_node_key.


      READ TABLE me-&gt;t_node_ddic INTO ls_node
                             WITH KEY node_key = ls_node_key.

      IF sy-subrc NE 0
      OR ls_node-isfolder = abap_true. &quot;may not append
        MESSAGE &apos;Only fields can be drag&amp;drop to editor&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        RETURN.
      ENDIF.

* Get text for the node selected
      lv_text = me-&gt;get_fld_frm_ddic_node(
                  iv_node_key  = ls_node_key
                  iv_relat_key = ls_node-relatkey
                  ).

      APPEND lv_text TO lo_drag_object-&gt;fields.

    ENDLOOP.
* Store the node text
    drag_drop_object-&gt;object = lo_drag_object.


  ENDMETHOD.                    &quot;hnd_ddic_drag
  METHOD get_fld_frm_ddic_node.
    DATA :
      ls_item        TYPE mtreeitm,
      ls_item_parent TYPE mtreeitm.

    DATA:
      lv_table       TYPE string,
      lv_alias       TYPE string.

* Get field name
    READ TABLE me-&gt;t_item_ddic INTO ls_item
                           WITH KEY node_key = iv_node_key
                                   item_name = &apos;col1&apos;.

* Get table name
    READ TABLE me-&gt;t_item_ddic INTO ls_item_parent
                           WITH KEY node_key = iv_relat_key
                                   item_name = &apos;col1&apos;.

* Search for alias
    SPLIT ls_item_parent-text AT &apos; AS &apos; INTO lv_table lv_alias.
    IF NOT lv_alias IS INITIAL.
      lv_table = lv_alias.
    ENDIF.

* Build tablename~fieldname
*  CONCATENATE lv_table &apos;~&apos; ls_item-text INTO rv_text.
    rv_text = ls_item-text.
    CONCATENATE space rv_text space INTO rv_text RESPECTING BLANKS.


  ENDMETHOD.                    &quot;get_fld_frm_ddic_node
  METHOD hnd_ddic_item_dblclick.
    DATA :
      ls_node        TYPE treev_node,
      ls_query       TYPE soli,
      ls_item        TYPE mtreeitm,
      ls_item_parent TYPE mtreeitm,
      ls_txt         TYPE string .

    DATA:
      lv_join        TYPE abap_bool.

    DATA:
      lt_query       TYPE soli_tab,
      lt_txt         TYPE soli_tab.

* Check clicked node is valid
    READ TABLE me-&gt;t_node_ddic INTO ls_node
                           WITH KEY node_key = node_key.
    IF sy-subrc &lt;&gt; 0
    OR ls_node-isfolder = abap_true.
      RETURN.
    ENDIF.

* Get text for the node selected
* Get field name
    READ TABLE me-&gt;t_item_ddic INTO ls_item
                           WITH KEY node_key = node_key
                                    item_name = &apos;col1&apos;.

* Get table name
    READ TABLE me-&gt;t_item_ddic INTO ls_item_parent
                           WITH KEY node_key  = ls_node-relatkey
                                    item_name = &apos;col1&apos;.

* Search for alias
*  SPLIT ls_item_parent-text AT &apos; AS &apos; INTO lw_table lw_alias.
*  IF NOT lw_alias IS INITIAL.
*    lv_table = lw_alias.
*  ENDIF.
*  ls_txt = ls_item_parent-text.

    me-&gt;o_textedit-&gt;get_text(
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1
      ).

    DELETE lt_query WHERE line+0(1) = &apos;*&apos;.

    LOOP AT lt_query INTO ls_query.

      CHECK ls_query-line CS &apos;JOIN&apos;.
      lv_join = abap_true.
      EXIT.
    ENDLOOP.

    IF lv_join = abap_true.
      ls_txt = | { ls_item_parent-text }~{ ls_item-text } |.
    ELSE.
      ls_txt = | { ls_item-text } |.
    ENDIF.

    APPEND ls_txt TO lt_txt.

    me-&gt;set_txt_at_cursor(  lt_txt  ).

  ENDMETHOD.                    &quot;hnd_ddic_item_dblclick

  METHOD constructor.

    SET HANDLER me-&gt;hnd_ddic_toolbar_clic FOR w-o_toolbar .
    me-&gt;ddic_init( ).

    me-&gt;editor_init( ).

    me-&gt;query_repo_init( ).
* Push to Object table list.
    lcl_app=&gt;push_list( iv_ref = me ).

  ENDMETHOD.                    &quot;constructor
  METHOD get_file_path.

    DATA:
      lv_path       TYPE string,
      lv_file       TYPE string.

    cl_gui_frontend_services=&gt;file_save_dialog(
    EXPORTING
*        window_title              =     &quot; Window Title
*        default_extension         =     &quot; Default Extension
*        default_file_name         =     &quot; Default File Name
*        with_encoding             =
*        file_filter               =     &quot; File Type Filter Table
*        initial_directory         =     &quot; Initial Directory
      prompt_on_overwrite       = &apos;X&apos;
    CHANGING
      filename                  =  lv_file   &quot; File Name to Save
      path                      =  lv_path   &quot; Path to File
      fullpath                  =  rv_filepath   &quot; Path + File Name
*        user_action               =     &quot; User Action (C Class Const ACTION_OK, ACTION_OVERWRITE etc)
*        file_encoding             =
    EXCEPTIONS
      cntl_error                = 1
      error_no_gui              = 2
      not_supported_by_gui      = 3
      invalid_default_file_name = 4
      OTHERS                    = 5
      ).
    IF sy-subrc &lt;&gt; 0.
*     MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      RETURN.
    ENDIF.

  ENDMETHOD.                    &quot;get_file_path
  METHOD ret_tab_columns.

    DATA:
      lo_columns    TYPE REF TO cl_salv_columns_table,
      lo_salv       TYPE REF TO cl_salv_table.

    DATA:
      lt_column_ref TYPE salv_t_column_ref.

    DATA:
      ls_column_ref TYPE salv_s_column_ref,
      ls_header     TYPE ty_header.

    REFRESH et_header.

    TRY.

        cl_salv_table=&gt;factory(
          IMPORTING
            r_salv_table   =  lo_salv   &quot; Basis Class Simple ALV Tables
          CHANGING
            t_table        = ct_data
        ).

      CATCH cx_salv_msg.    &quot; ALV: General Error Class with Message

        RETURN.

    ENDTRY.

    lo_columns = lo_salv-&gt;get_columns( ).

    lt_column_ref = lo_columns-&gt;get( ).

    LOOP AT lt_column_ref INTO ls_column_ref.

      ls_header = ls_column_ref-r_column-&gt;get_long_text( ).

      APPEND ls_header TO et_header.
    ENDLOOP.

  ENDMETHOD.                    &quot;ret_tab_columns
  METHOD exec2pc.

    FIELD-SYMBOLS:
      &lt;lt_data&gt;     TYPE STANDARD TABLE.

    DATA:
      lt_content    TYPE STANDARD TABLE OF ty_header.

    DATA:
      lv_fullpath   TYPE string.

    DATA:
      lo_struc      TYPE REF TO cl_abap_structdescr,
      lo_type       TYPE REF TO cl_abap_typedescr     .

    lv_fullpath = me-&gt;get_file_path( ).

    IF lv_fullpath IS INITIAL.

      RETURN.

    ENDIF.
    me-&gt;execute( ).

    ASSIGN me-&gt;o_tab-&gt;* TO &lt;lt_data&gt;.

    IF &lt;lt_data&gt; IS NOT ASSIGNED
    OR &lt;lt_data&gt; IS INITIAL.

      RETURN.
    ENDIF.

    me-&gt;ret_tab_columns(
      IMPORTING
        et_header = lt_content
      CHANGING
        ct_data   = &lt;lt_data&gt;
    ).

    cl_gui_frontend_services=&gt;gui_download(
      EXPORTING
        filename                  =  lv_fullpath &quot; Name of file
        write_field_separator     = &apos;X&apos;    &quot; Separate Columns by Tabs in Case of ASCII Download
        fieldnames                =  lt_content   &quot; Table Field Names
      CHANGING
        data_tab                  =  &lt;lt_data&gt;   &quot; Transfer table
      EXCEPTIONS
        OTHERS                    = 1
        ).

    IF sy-subrc &lt;&gt; 0.
*     MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    CLEAR me-&gt;o_tab.

  ENDMETHOD.                    &quot;exec2pc


  METHOD exec2bg.

    DATA:
      lv_jobcount          TYPE btcjobcnt,
      lv_valid_flag        TYPE c           LENGTH 1,
      lv_query             TYPE string.

    DATA :
      ls_print_parameters  TYPE pri_params,
      ls_archi_parameters  TYPE arc_params.

    DATA:
      lt_query             TYPE soli_tab.

    me-&gt;o_textedit-&gt;get_text(
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1
        ).

    IF syst-subrc &lt;&gt; 0 .
      RETURN.
    ENDIF.

*     Schedule job.
    CALL FUNCTION &apos;JOB_OPEN&apos;
      EXPORTING
        jobname          = &apos;ZQUERY&apos;
      IMPORTING
        jobcount         = lv_jobcount
      EXCEPTIONS
        cant_create_job  = 1
        invalid_job_data = 2
        jobname_missing  = 3
        OTHERS           = 4.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;GET_PRINT_PARAMETERS&apos;
      EXPORTING
        expiration             = &apos;2&apos;
        immediately            = &apos; &apos;
        line_size              = 120
        line_count             = 44
        new_list_id            = &apos;X&apos;
        no_dialog              = &apos;X&apos;
        release                = &apos;X&apos;
        sap_cover_page         = &apos; &apos;
      IMPORTING
        out_parameters         = ls_print_parameters
        out_archive_parameters = ls_archi_parameters
        valid                  = lv_valid_flag
      EXCEPTIONS
        OTHERS                 = 4.

    IF lv_valid_flag = &apos;X&apos;
    AND syst-subrc    = 0.

      lv_query = lcl_app=&gt;qtab_to_string( lt_query ).

      SUBMIT zrd_query TO SAP-SPOOL
                       SPOOL   PARAMETERS ls_print_parameters
                       ARCHIVE PARAMETERS ls_archi_parameters
                       WITHOUT SPOOL DYNPRO
                       VIA JOB &apos;ZQUERY&apos; NUMBER lv_jobcount
                       WITH p_query = lv_query
                       WITH p_upto  = lcl_app=&gt;default_rows
                       AND RETURN.

    ENDIF.

*     Release Job.
    CALL FUNCTION &apos;JOB_CLOSE&apos;
      EXPORTING
        jobcount  = lv_jobcount
        jobname   = &apos;ZQUERY&apos;
        strtimmed = &apos;X&apos;
      EXCEPTIONS
        OTHERS    = 9.
    IF sy-subrc = 0.
      MESSAGE s000(db) WITH &apos;Query Submitted with Background Job Name: ZQUERY&apos; .
    ENDIF.

  ENDMETHOD.                    &quot;exec2bg
  METHOD check_query.
    DATA:
      lt_query          TYPE soli_tab,
      lt_prog           TYPE string_table.

    DATA:
      lv_select         TYPE string,
      lv_from           TYPE string,
      lv_where          TYPE string,
      lv_msg            TYPE char255,
      lv_string         TYPE string,
      lv_line           TYPE i,
      lv_word           TYPE char30,
      lv_upto           TYPE i,
      lv_order          TYPE string,
      lv_group          TYPE string.

    CLEAR lv_line.

    me-&gt;o_textedit-&gt;get_text(
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1
      ).

    lcl_app=&gt;ret_query_comp(
      EXPORTING
        iv_query  = lcl_app=&gt;qtab_to_string( lt_query )
      IMPORTING
        ev_from   = lv_from
        ev_select = lv_select
        ev_where  = lv_where
        ev_upto   = lv_upto
        ev_order  = lv_order
        ev_group  = lv_group
      ).

    IF lv_upto IS INITIAL.
      lv_upto = lcl_app=&gt;default_rows.
    ENDIF.

    APPEND &apos;REPORT ZRD_QUERY.&apos; TO lt_prog.

    APPEND &apos;    FIELD-SYMBOLS:      &lt;lfs_data&gt;         TYPE STANDARD TABLE.&apos; TO lt_prog.

    APPEND &apos;START-OF-SELECTION.&apos; TO lt_prog.

    REFRESH lt_query.

    lv_string = |SELECT { lv_select }|.
    APPEND lv_string TO lt_prog.

    lv_string = |FROM { lv_from }|.
    APPEND lv_string TO lt_prog.

    IF lv_upto IS NOT INITIAL.
      lv_string = |UP TO { lv_upto } ROWS|.

      APPEND lv_string TO lt_prog.
    ENDIF.

    lv_string = |INTO TABLE &lt;lfs_Data&gt;|.
    APPEND lv_string TO lt_prog.

    IF lv_where IS NOT INITIAL.
      lv_string = |WHERE { lv_where }|.
      APPEND lv_string TO lt_prog.

    ENDIF.

    IF lv_order IS NOT INITIAL.
      lv_string = |ORDER BY { lv_order }|.
      APPEND lv_string TO lt_prog.
    ENDIF.

    IF lv_group IS NOT INITIAL.
      lv_string = |GROUP BY { lv_group }|.
      APPEND lv_string TO lt_prog.
    ENDIF.

    APPEND &apos;.&apos; TO lt_prog.

    SYNTAX-CHECK FOR lt_prog
    MESSAGE lv_msg LINE lv_line WORD lv_word.

    IF lv_msg IS NOT INITIAL.

      MESSAGE lv_msg TYPE &apos;E&apos;.&quot; DISPLAY LIKE &apos;E&apos;.
      RETURN.

    ENDIF.


  ENDMETHOD.                    &quot;check_query
  METHOD report_estimated_qrows.
    DATA:
      lt_query   TYPE soli_tab.

    DATA:
      lv_select      TYPE string,
      lv_from        TYPE string,
      lv_where       TYPE string,
      lv_query       TYPE string,
      lv_est_row     TYPE char32,
      lv_upto        TYPE i.

    me-&gt;o_textedit-&gt;get_text( IMPORTING table  = lt_query[]
                             EXCEPTIONS OTHERS = 1
      ).

    lcl_app=&gt;ret_query_comp( EXPORTING iv_query  = lcl_app=&gt;qtab_to_string( lt_query )
                             IMPORTING ev_from   = lv_from
                                       ev_select = lv_select
                                       ev_where  = lv_where
                                       ev_upto   = lv_upto
                            ).



    lv_query = | SELECT { lv_select } FROM { lv_from } { lcl_app=&gt;ret_ora_whr_str( iv_whr = lv_where iv_upto = lv_upto ) } |.

    lv_query = replace( val   = lv_query
                        sub   = &apos;~&apos;
                        occ   = 0
                        with  = &apos;.&apos;
               ).
    lv_est_row = lcl_app=&gt;get_est_rows( lv_query ).

    IF lv_est_row IS NOT INITIAL.

      MESSAGE s000(db) WITH &apos;Query Is Correct ,Estimated result rows are:&apos; lv_est_row.
    ENDIF.
  ENDMETHOD.                    &quot;report_estimated_qrows
  METHOD exit_app.
    DATA :
      lv_ans TYPE char1.

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question = &apos;Are You Sure to Exit?&apos;
        text_button_1 = &apos;Yes&apos;(001)
        text_button_2 = &apos;No&apos;(002)
      IMPORTING
        answer        = lv_ans
      EXCEPTIONS
        OTHERS        = 2.
    IF  sy-subrc = 0
    AND lv_ans = &apos;1&apos;.

      LEAVE TO SCREEN 0.

    ENDIF.

  ENDMETHOD.                    &quot;exit_app
  METHOD handle_qsave.
    DATA:
      lv_ans    TYPE char1,
      lv_string TYPE string.

    DATA:
      lr_ugroup TYPE usselgroup,
      lr_vuser  TYPE trgs_user_name.

    DATA:
      lrt_ugroup TYPE RANGE OF xuclass,
      lrt_vuser  TYPE trgr_user_name,
      lt_string  TYPE string_table      .

    CLEAR:
      w-vis_users,
      w-qname,
      w-qvisibility,
      me-&gt;v_qovrwrt.




    IF w-visibilitygrp IS INITIAL.

      SELECT SINGLE class
             INTO w-visibilitygrp
             FROM usr02
             WHERE bname = sy-uname.

    ENDIF.

    IF  me-&gt;s_ztquery-queryid IS NOT INITIAL
    AND me-&gt;s_ztquery-owner  = syst-uname.

      CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
        EXPORTING
*              TITLEBAR                    = &apos; &apos;
*              DIAGNOSE_OBJECT             = &apos; &apos;
        text_question               = &apos;OVER Write Query&apos;
        text_button_1               = &apos;Yes&apos;(001)
*              ICON_BUTTON_1               = &apos; &apos;
        text_button_2               = &apos;No&apos;(002)
*              ICON_BUTTON_2               = &apos; &apos;
*              DEFAULT_BUTTON              = &apos;1&apos;
*              DISPLAY_CANCEL_BUTTON       = &apos;X&apos;
*              USERDEFINED_F1_HELP         = &apos; &apos;
*              START_COLUMN                = 25
*              START_ROW                   = 6
*              POPUP_TYPE                  =
*              IV_QUICKINFO_BUTTON_1       = &apos; &apos;
*              IV_QUICKINFO_BUTTON_2       = &apos; &apos;
      IMPORTING
        answer                      = lv_ans
*            TABLES
*              PARAMETER                   =
      EXCEPTIONS
        text_not_found              = 1
        OTHERS                      = 2
        .

      IF sy-subrc &lt;&gt; 0
      OR lv_ans &lt;&gt; &apos;1&apos;
     AND lv_ans &lt;&gt; &apos;2&apos;.

        RETURN.

* Implement suitable error handling here
      ENDIF.



      IF lv_ans = &apos;1&apos;.

        me-&gt;v_qovrwrt = abap_true.

        CLEAR:
          w-visibilitygrp.

* Get Shared User Group.

        lv_string = me-&gt;s_ztquery-visibility_group.

        lrt_ugroup[] = lcl_app=&gt;str_2_range( lv_string ).

        READ TABLE lrt_ugroup INTO lr_ugroup INDEX 1.

        IF lr_ugroup IS NOT INITIAL.

          w-visibilitygrp = lr_ugroup-low.

          WRITE icon_display_more AS ICON TO w-ugroup_sel_more.

        ELSE.

          WRITE icon_enter_more AS ICON TO w-ugroup_sel_more.

        ENDIF.

* Get Shared Users.

        lv_string = me-&gt;s_ztquery-visibility_users.

        lrt_vuser[] = lcl_app=&gt;str_2_range( lv_string ) .

        READ TABLE lrt_vuser INTO lr_vuser INDEX 1.

        IF lr_vuser IS NOT INITIAL.

          w-vis_users = lr_vuser-low.

          WRITE icon_display_more AS ICON TO w-vuser_sel_more.

        ELSE.

          WRITE icon_enter_more AS ICON TO w-vuser_sel_more.

        ENDIF.

        w-qname       = me-&gt;s_ztquery-text.
        w-qvisibility = me-&gt;s_ztquery-visibility.
*        w-qvisibility = me-&gt;s_ztquery-visibility.
*
*        SPLIT  me-&gt;s_ztquery-visibility_group
*           AT space
*         INTO TABLE lt_string.
*
*        READ TABLE lt_string INTO lv_string INDEX 1.
*
*        IF syst-subrc IS INITIAL.
*          w-visibilitygrp = lv_string.
*        ENDIF.
*
*        REFRESH:
*          lt_string.
*
*        SPLIT  me-&gt;s_ztquery-visibility_users
*           AT space
*         INTO TABLE lt_string.
*
*        READ TABLE lt_string INTO lv_string INDEX 1.
*
*        IF syst-subrc IS INITIAL.
*          w-vis_users = lv_string.
*        ENDIF.
*
      ENDIF.

    ENDIF.

    CALL SCREEN 9300 STARTING AT 10 5
    ENDING AT 60 7.

  ENDMETHOD.                    &quot;handle_qsave
  METHOD handle_ucomm.

    DATA:
      lv_index TYPE sytabix.

    DATA:
      lo_err   TYPE REF TO lcl_error.

    er_app_ref = me.

    TRY.

        CASE w_okcode.
          WHEN &apos;EXP&apos;.

            lcl_app=&gt;col_exp_repo( ).

          WHEN &apos;SAVE&apos;.

            me-&gt;handle_qsave( ).

          WHEN &apos;MSUGROUP&apos;.

            IF  w-qvisibility &lt;&gt; &apos;1&apos;.

              MESSAGE s000(db) WITH &apos;Visibility User Group needed for Shared queries&apos; DISPLAY LIKE &apos;E&apos;.
            ELSE.

              me-&gt;hndl_ugroup_multi( ).
            ENDIF.

          WHEN &apos;MSVUSER&apos;.

            IF  w-qvisibility &lt;&gt; &apos;1&apos;.

              MESSAGE s000(db) WITH &apos;Visibility User Group needed for Shared queries&apos; DISPLAY LIKE &apos;E&apos;.
            ELSE.

              me-&gt;hndl_vuser_multi( ).
            ENDIF.

          WHEN &apos;CHECK&apos;.

            me-&gt;check_query( ).

            MESSAGE s000(db) WITH &apos;Query is syntacticly correct&apos;.

            me-&gt;report_estimated_qrows( ).

          WHEN &apos;EXIT&apos;.

            me-&gt;exit_app( ).

          WHEN &apos;EXECUTE&apos;.

            me-&gt;check_query( ).

            me-&gt;execute( ).

            me-&gt;set_tab_title( ).

            me-&gt;add_repo_local( ).

          WHEN &apos;NEW&apos;.

            lcl_app=&gt;chk_limit( ).

            er_app_ref = me-&gt;ret_tab_obj( ).

          WHEN &apos;DEL_TAB&apos;.

            lv_index = w_tabstrip-activetab+3 - 1.

            er_app_ref = me-&gt;ret_tab_obj( lv_index  ).

            lcl_app=&gt;pop_list( lv_index + 1 ).

            w_tabstrip-activetab = |TAB{ lv_index }|.

          WHEN &apos;QWIZ&apos;.

            CALL SCREEN 9100 STARTING AT 5 5.

          WHEN &apos;CLOSE_QWIZ&apos;.

            LEAVE TO SCREEN 0.

          WHEN &apos;OK_QWIZ&apos;.

            me-&gt;gen_query( ).

            LEAVE TO SCREEN 0.

          WHEN &apos;GET_FLD&apos;.

            lcl_app=&gt;chk_tabnm_empt_vald( w-sel_tabname ).

            lcl_app=&gt;handle_sqlfld( w-sel_tabname ).

          WHEN &apos;REFRESH&apos;.

            lcl_app=&gt;rfrsh_qwiz_data( ).

          WHEN &apos;EXEC2PC&apos;.

            me-&gt;check_query( ).

            me-&gt;exec2pc( ).

            me-&gt;set_tab_title( ).



          WHEN &apos;SETTINGS&apos;.

            lcl_app=&gt;handle_settings( iv_ucomm ).

          WHEN &apos;CLOSE_SET&apos;
            OR &apos;OK_SET&apos;
            OR &apos;CLOSE&apos;.

            LEAVE TO SCREEN 0.

          WHEN &apos;OK_SAVE&apos;.


            IF  w-qvisibility = &apos;1&apos;
            AND w-visibilitygrp IS INITIAL
            AND w-vis_users IS INITIAL.

              MESSAGE s000(db) WITH &apos;Visibility User/User Group needed for Shared queries&apos; DISPLAY LIKE &apos;E&apos;.

            ELSEIF w-qvisibility &lt;&gt; &apos;1&apos;
            AND ( w-visibilitygrp IS NOT INITIAL
                OR me-&gt;s_ztquery-visibility_group IS NOT INITIAL
                OR w-vis_users IS NOT INITIAL
                OR me-&gt;s_ztquery-visibility_users IS NOT INITIAL ) .

              MESSAGE s000(db) WITH &apos;Visibility User/User Group needed only for Shared queries&apos; DISPLAY LIKE &apos;E&apos;.

            ELSE.

              me-&gt;init_save_query( ).

              LEAVE TO SCREEN 0.

            ENDIF.

          WHEN &apos;EXEC2BG&apos;.

            me-&gt;check_query( ).

            me-&gt;exec2bg( ).

            me-&gt;set_tab_title( ).

          WHEN OTHERS.

            IF w_okcode(3) = &apos;TAB&apos;
            AND w_tabstrip-activetab NE iv_ucomm.

              lv_index = iv_ucomm+3.

              er_app_ref = me-&gt;ret_tab_obj( lv_index ).

              w_tabstrip-activetab = iv_ucomm.

            ENDIF.

        ENDCASE.

      CATCH lcl_error INTO lo_err.

        MESSAGE s000(db) WITH lo_err-&gt;v_text DISPLAY LIKE &apos;E&apos;.

    ENDTRY.

  ENDMETHOD.                    &quot;handle_ucomm
  METHOD init_save_query.
    DATA:
      lt_query TYPE soli_tab.

    me-&gt;o_textedit-&gt;get_text( IMPORTING table      =  lt_query   &quot; document text
                             EXCEPTIONS OTHERS     = 3
                            ).

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = &apos;Error fetching query from editor.&apos;.
    ENDIF.

    IF me-&gt;v_qovrwrt = abap_false.
      CLEAR:
        me-&gt;s_ztquery-queryid.
    ENDIF.

    lcl_app=&gt;save_query( EXPORTING iv_query   = lcl_app=&gt;qtab_to_string( it_query = lt_query
                                                                         iv_com   = abap_true
                                                                         iv_sep   = cl_abap_char_utilities=&gt;cr_lf
                                                                        )
                          CHANGING cs_ztquery = me-&gt;s_ztquery
                       ).

    CLEAR:
       me-&gt;v_qovrwrt.

    me-&gt;load_repo( ).

  ENDMETHOD.                    &quot;init_Save_query
  METHOD gen_query.

    DATA:
      lt_query TYPE string_table.

    lt_query = lcl_app=&gt;ret_query( ).

    IF lt_query IS NOT INITIAL.

      me-&gt;o_textedit-&gt;set_text(
        EXPORTING
          table           = lt_query
        EXCEPTIONS
          error_dp        = 1
          error_dp_create = 2
          error_code_page = 3
          OTHERS          = 4
          ).

      IF sy-subrc &lt;&gt; 0.
* message id sy-msgid type sy-msgty number sy-msgno
*            with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    ENDIF.

    me-&gt;set_focus_on_editor( ).

  ENDMETHOD.                    &quot;gen_query

  METHOD leave_current_tab.
    DATA:
      lv_index TYPE sytabix.

    me-&gt;handle_visibility( iv_ref = me
                           iv_vis = abap_false
                          ).

    CALL METHOD cl_gui_cfw=&gt;flush.

    lv_index = w_tabstrip-activetab+3.

    lcl_app=&gt;modif_list( iv_index = lv_index
                          iv_ref  = me
                       ).


  ENDMETHOD.                    &quot;leave_current_tab
  METHOD handle_visibility.

    iv_ref-&gt;o_textedit-&gt;set_visible( EXPORTING visible = iv_vis ).

    IF iv_ref-&gt;o_dock IS NOT INITIAL.
      iv_ref-&gt;o_dock-&gt;set_visible( EXPORTING visible = iv_vis ).
    ENDIF.

    IF iv_ref-&gt;o_tree_ddic IS NOT INITIAL.
      iv_ref-&gt;o_tree_ddic-&gt;set_visible( EXPORTING visible           =  iv_vis   &quot; Visible
                                       EXCEPTIONS OTHERS            = 0
                                      ).

    ENDIF.

    IF iv_ref-&gt;o_tree_qrep IS NOT INITIAL.
      iv_ref-&gt;o_tree_qrep-&gt;set_visible( EXPORTING visible           =  iv_vis   &quot; Visible
                                       EXCEPTIONS OTHERS            = 0
                                      ).

    ENDIF.

    SET HANDLER iv_ref-&gt;hnd_ddic_toolbar_clic FOR w-o_toolbar ACTIVATION iv_vis.

  ENDMETHOD.                    &quot;handle_visibility
  METHOD ret_tab_obj.

    me-&gt;leave_current_tab( ).

    IF iv_index IS NOT INITIAL.

      app_ref = lcl_app=&gt;read_list( iv_index ).

      IF app_ref IS NOT INITIAL.

* Display editor / ddic / alv
        me-&gt;handle_visibility( iv_ref = app_ref
                               iv_vis = abap_true
                             ).

      ENDIF.

    ELSE.

* Start new tab

      w_tabstrip-activetab = |TAB{ lines( lcl_app=&gt;t_list ) + 1 } |.&quot;_tab.

      CREATE OBJECT app_ref.
      SET HANDLER app_ref-&gt;hnd_ddic_toolbar_clic FOR w-o_toolbar .
    ENDIF.

    w-o_toolbar-&gt;set_button_visible( EXPORTING visible = app_ref-&gt;v_editable    &quot; Show/Hide
                                               fcode   = &apos;SET_FLD_IP&apos;     &quot; Function Code
                                    EXCEPTIONS OTHERS  = 0
    ).

  ENDMETHOD.                    &quot;RET_TAB_OBJ
  METHOD dock_init.

    CREATE OBJECT o_dock
      EXPORTING
        side                        = cl_gui_docking_container=&gt;dock_at_bottom    &quot; Side to Which Control is Docked
        style                       = cl_gui_control=&gt;ws_child + cl_gui_control=&gt;ws_thickframe + cl_gui_control=&gt;ws_visible  &quot; Windows Style Attributes Applied to This Docking Container
        ratio                       = 40    &quot; Percentage of Screen: Takes Priority Over EXTENSION
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        OTHERS                      = 6.
    IF sy-subrc &lt;&gt; 0.
*     MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

  ENDMETHOD.                    &quot;dock_init
  METHOD editor_init.
    DATA:
      lo_completer TYPE REF TO cl_abap_parser,
      lo_dragdrop  TYPE REF TO cl_dragdrop.

    CHECK w-o_qcontainer IS NOT INITIAL.

    CREATE OBJECT me-&gt;o_textedit
      EXPORTING
        parent           = w-o_qcontainer    &quot; Parent container
        max_number_chars = 72.    &quot; Maximum Number of Characters


    IF me-&gt;o_textedit IS  INITIAL.

      RETURN.
    ENDIF.
    CALL METHOD me-&gt;o_textedit-&gt;(&apos;INIT_COMPLETER&apos;).

    CALL METHOD me-&gt;o_textedit-&gt;(&apos;GET_COMPLETER&apos;)
      RECEIVING
        m_parser = lo_completer.

    SET HANDLER lo_completer-&gt;handle_completion_request
            FOR me-&gt;o_textedit.

    SET HANDLER lo_completer-&gt;handle_insertion_request
            FOR me-&gt;o_textedit.

    SET HANDLER lo_completer-&gt;handle_quickinfo_request
            FOR me-&gt;o_textedit.

    SET HANDLER me-&gt;hnd_editor_dblclk
            FOR me-&gt;o_textedit.

    SET HANDLER me-&gt;hnd_editor_drop
           FOR me-&gt;o_textedit.

    me-&gt;o_textedit-&gt;register_event_completion( ).
    me-&gt;o_textedit-&gt;register_event_quick_info( ).
    me-&gt;o_textedit-&gt;register_event_insert_pattern( ).
    me-&gt;o_textedit-&gt;register_event_f1( ).

    me-&gt;o_textedit-&gt;register_event_dblclick(
      EXPORTING
        navigate_on_dblclick     =   0  &quot; default: no local navigation on dblclick
      EXCEPTIONS
        error_regist_event       = 1
        error_unregist_event     = 2
        cntl_error               = 3
        event_already_registered = 4
        event_not_registered     = 5
        OTHERS                   = 6
        ).

    IF sy-subrc &lt;&gt; 0.
*         MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

* Manage Drag from DDIC editor
    CREATE OBJECT lo_dragdrop.

    lo_dragdrop-&gt;add(
      flavor     = &apos;EDIT_INSERT&apos;
      dragsrc    = space
      droptarget = abap_true
      effect     = cl_dragdrop=&gt;copy
      ).

    me-&gt;o_textedit-&gt;set_dragdrop(
      dragdrop = lo_dragdrop
      ).

    me-&gt;o_textedit-&gt;set_text(
      EXPORTING
        table           = lcl_app=&gt;get_q_template( )
      EXCEPTIONS
        error_dp        = 1
        error_dp_create = 2
        error_code_page = 3
        OTHERS          = 4
      ).

    IF sy-subrc &lt;&gt; 0.
* m   ssage id sy-msgid type sy-msgty number sy-msgno
*              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    me-&gt;set_focus_on_editor( ).

  ENDMETHOD.                    &quot;editor_init
  METHOD set_focus_on_editor.

    cl_gui_control=&gt;set_focus(
      control = me-&gt;o_textedit
      ).
  ENDMETHOD.                    &quot;set_focus_on_editor

  METHOD set_tab_visible.

    DATA :
      lv_num TYPE i,
      lv_max TYPE i.

    lv_max = lines( lcl_app=&gt;t_list ).

    LOOP AT SCREEN.

      CHECK screen-name(15) = &apos;W-TAB_TITLE-TAB&apos;.

      lv_num = screen-name+15.

      IF lv_num &gt; lv_max.
        screen-invisible = 1.
      ELSE.
        screen-invisible = 0.
      ENDIF.

      MODIFY SCREEN.

    ENDLOOP.

*    * Focus on editor
    me-&gt;set_focus_on_editor( ).

  ENDMETHOD.                    &quot;set_tab_visible
  METHOD set_tab_title.
    DATA :
      lv_name(40) TYPE c,
      lt_query    TYPE soli_tab,
      ls_query    TYPE soli.

    FIELD-SYMBOLS:
      &lt;fs_title&gt;  TYPE any.

    IF w_tabstrip-activetab IS INITIAL.
      lv_name = &apos;W-TAB_TITLE-TAB1&apos;.
    ELSE.
      CONCATENATE &apos;W-TAB_TITLE-TAB&apos; w_tabstrip-activetab+3 INTO lv_name.
    ENDIF.

    ASSIGN (lv_name) TO &lt;fs_title&gt;.

    IF sy-subrc NE 0.
      RETURN.
    ENDIF.

* Basic read query to check if first line is a comment
    CALL METHOD me-&gt;o_textedit-&gt;get_text
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1.

    IF syst-subrc IS INITIAL.


      lcl_app=&gt;ret_query_comp(
      EXPORTING
        iv_query  = lcl_app=&gt;qtab_to_string( lt_query )
      IMPORTING
        ev_from   = &lt;fs_title&gt;

        ).

    ENDIF.
  ENDMETHOD.                    &quot;set_tab_title
  METHOD alv_init.

    DATA:
      lo_func   TYPE REF TO cl_salv_functions,
      lo_events TYPE REF TO cl_salv_events_table.

    TRY.

        cl_salv_table=&gt;factory(
          EXPORTING
            r_container = me-&gt;o_dock
          IMPORTING
            r_salv_table = o_alv
          CHANGING
            t_table      = it_data
          ).

        lo_func =  me-&gt;o_alv-&gt;get_functions( ).

        lo_func-&gt;add_function(
          name     = &apos;CLOSE_GRID&apos;   &quot; ALV Function
          icon     = &apos;@3X@&apos;
          text     = &apos;CLOSE&apos;
          tooltip  = &apos;Close&apos;
          position =  if_salv_c_function_position=&gt;right_of_salv_functions   &quot; Positioning Function
          ).

        lo_func-&gt;set_all( ).

        lo_func-&gt;set_function(
          name    =  &apos;CLOSE_GRID&apos;   &quot; ALV Function
          boolean =  c-x   &quot;Boolean Variable (X=True, Space=False)
          ).

        lo_events = me-&gt;o_alv-&gt;get_event( ).

        SET HANDLER me-&gt;on_user_command FOR lo_events.

        me-&gt;alv_set_columns( o_alv ).

        o_alv-&gt;display( ).

      CATCH cx_salv_error.

        RETURN.

    ENDTRY.

  ENDMETHOD.                    &quot;alv_init
  METHOD alv_set_columns.

    DATA:
      lo_columns    TYPE REF TO cl_salv_columns_table,
      lt_column_ref TYPE salv_t_column_ref,
      ls_column_ref TYPE salv_s_column_ref.      .

    DATA:
      lv_scrtxt_l     TYPE scrtext_l,
      lv_scrtxt_m     TYPE scrtext_m,
      lv_scrtxt_s     TYPE scrtext_s,
      lv_editmask     TYPE lvc_edtmsk,
      lv_internaltype TYPE inttype.

    lo_columns = io_alv-&gt;get_columns( ).

    lt_column_ref = lo_columns-&gt;get( ).

    LOOP AT lt_column_ref INTO ls_column_ref.

      IF lcl_app=&gt;conversion = abap_false.

        lv_editmask = ls_column_ref-r_column-&gt;get_edit_mask( ).
        IF  lv_editmask(2) =  &apos;==&apos;.
          ls_column_ref-r_column-&gt;set_edit_mask( space ).
        ENDIF.

        lv_internaltype = ls_column_ref-r_column-&gt;get_ddic_inttype( ).

        IF lv_internaltype = &apos;C&apos;
        OR lv_internaltype = &apos;N&apos;.
          ls_column_ref-r_column-&gt;set_leading_zero( ).
        ENDIF.

      ENDIF.
      IF lcl_app=&gt;techname = abap_true.
        lv_scrtxt_s = lv_scrtxt_m = lv_scrtxt_l = ls_column_ref-columnname.
        ls_column_ref-r_column-&gt;set_long_text( lv_scrtxt_l ).
        ls_column_ref-r_column-&gt;set_medium_text( lv_scrtxt_m ).
        ls_column_ref-r_column-&gt;set_short_text( lv_scrtxt_s ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    &quot;alv_set_columns
  METHOD alv_disp.

    FIELD-SYMBOLS:
      &lt;lfs_data&gt; TYPE STANDARD TABLE.

    ASSIGN me-&gt;o_tab-&gt;* TO &lt;lfs_data&gt;.

    IF &lt;lfs_data&gt; IS NOT ASSIGNED
    OR &lt;lfs_data&gt; IS INITIAL.

      RETURN.
    ENDIF.

    IF me-&gt;o_dock IS INITIAL.

      me-&gt;dock_init( ).

    ENDIF.

    me-&gt;o_dock-&gt;set_visible(  EXPORTING visible           = c-x    &quot; Visible
                             EXCEPTIONS cntl_error        = 1
                                        cntl_system_error = 2
                                        OTHERS            = 3
                           ).

    IF sy-subrc &lt;&gt; 0.
*     do nothing for now
    ENDIF.

    IF me-&gt;o_alv IS INITIAL.

      me-&gt;alv_init( CHANGING  it_data =  &lt;lfs_data&gt; ).

    ELSE.

      TRY.
          me-&gt;o_alv-&gt;set_data( CHANGING t_table =  &lt;lfs_data&gt; ).  &quot; Table to Be Displayed
*          IF  lcl_app=&gt;techname = abap_true.
          me-&gt;alv_set_columns( me-&gt;o_alv ).
*          ENDIF.
          me-&gt;o_alv-&gt;refresh( refresh_mode = if_salv_c_refresh=&gt;full  ).  &quot; ALV: Data Element for Constants
*          cl_gui_cfw=&gt;flush( ).
        CATCH cx_root.    &quot; ALV: Setting New Data Not Allowed

      ENDTRY.



    ENDIF.

  ENDMETHOD.                    &quot;alv_disp

  METHOD scr_8000_output.

    DATA:
      lt_buttons TYPE STANDARD TABLE OF sy-ucomm.

    DATA:
      ls_buttons TYPE sy-ucomm.

    IF me-&gt;v_editable = abap_false.

      ls_buttons = &apos;QWIZ&apos;.
      APPEND ls_buttons TO lt_buttons.

    ENDIF.

    SET PF-STATUS &apos;PF_9000&apos; EXCLUDING lt_buttons.

    me-&gt;set_tab_visible( ).

    me-&gt;alv_disp( ).

  ENDMETHOD.                    &quot;scr_8000_output
  METHOD scr_9300_output.

    DATA:
      lv_string TYPE string.

    lv_string = me-&gt;s_ztquery-visibility_group.

    IF lines( lcl_app=&gt;str_2_range( lv_string ) ) &gt; 1.
      WRITE icon_display_more AS ICON TO w-ugroup_sel_more.
    ELSE.
      WRITE icon_enter_more AS ICON TO w-ugroup_sel_more.
    ENDIF.

    lv_string = me-&gt;s_ztquery-visibility_users.

    IF lines( lcl_app=&gt;str_2_range( lv_string ) ) &gt; 1.
      WRITE icon_display_more AS ICON TO w-vuser_sel_more.
    ELSE.
      WRITE icon_enter_more AS ICON TO w-vuser_sel_more.
    ENDIF.

*    IF me-&gt;v_qovrwrt = abap_true.
*
*      CLEAR:
*        w-visibilitygrp.
*
** Get Shared User Group.
*
*      lv_string = me-&gt;s_ztquery-visibility_group.
*
*      lrt_ugroup[] = lcl_app=&gt;str_2_range( lv_string ).
*
*      READ TABLE lrt_ugroup into lr_ugroup index 1.
*
*      if lr_ugroup IS NOT INITIAL.
*
*        w-visibilitygrp = lr_ugroup-low.
*
*        WRITE icon_display_more AS ICON TO w-ugroup_sel_more.
*
*      ELSE.
*
*        WRITE icon_enter_more AS ICON TO w-ugroup_sel_more.
*
*      ENDIF.
*
** Get Shared Users.
*
*      lv_string = me-&gt;s_ztquery-visibility_users.
*
*      lrt_vuser[] = lcl_app=&gt;str_2_range( lv_string ) .
*
*      READ TABLE lrt_vuser INTO lr_vuser INDEX 1.
*
*      IF lr_vuser IS NOT INITIAL.
*
*        w-vis_users = lr_vuser-low.
*
*        WRITE icon_display_more AS ICON TO w-vuser_sel_more.
*
*      ELSE.
*
*        WRITE icon_enter_more AS ICON TO w-vuser_sel_more.
*
*      ENDIF.
*
*      w-qname       = me-&gt;s_ztquery-text.
*      w-qvisibility = me-&gt;s_ztquery-visibility.
*
*    ENDIF.

    lcl_app=&gt;set_visdropdown( ).

  ENDMETHOD.                    &quot;SCR_9300_OUTPUT

  METHOD handle_output.

    DATA:
      lo_err   TYPE REF TO lcl_error.

    TRY.

        CASE iv_dynnr.

          WHEN &apos;8000&apos;.

            IF lcl_app=&gt;default_rows IS NOT INITIAL.
              w-max_row-text = |Max No. of Rows: { lcl_app=&gt;default_rows }|.
            ELSE.
              CLEAR w-max_row.
            ENDIF.

            me-&gt;scr_8000_output( ).

          WHEN &apos;9100&apos;.

            lcl_app=&gt;qwiz_output( ).

          WHEN &apos;9200&apos;.

            lcl_app=&gt;settings_output( ).

          WHEN &apos;9300&apos;.

            me-&gt;scr_9300_output( ).

        ENDCASE.
      CATCH lcl_error INTO lo_err.

        MESSAGE s000(db) WITH lo_err-&gt;v_text DISPLAY LIKE &apos;E&apos;.

    ENDTRY.

  ENDMETHOD.                    &quot;handle_output
  METHOD on_user_command.

    FIELD-SYMBOLS:
      &lt;lfs_data&gt; TYPE STANDARD TABLE.

    CASE e_salv_function.

      WHEN &apos;CLOSE_GRID&apos;.

        me-&gt;o_dock-&gt;set_visible(
          EXPORTING
            visible           =  space   &quot; Visible
          EXCEPTIONS
            cntl_error        = 1
            cntl_system_error = 2
            OTHERS            = 3
          ).

        IF sy-subrc &lt;&gt; 0.
          RETURN.
        ENDIF.

        ASSIGN o_tab-&gt;* TO &lt;lfs_data&gt;.

        IF &lt;lfs_data&gt; IS ASSIGNED.
          REFRESH &lt;lfs_data&gt;.
        ENDIF.

    ENDCASE.
  ENDMETHOD.                    &quot;on_user_command

  METHOD execute.

    DATA:
          lt_query   TYPE soli_tab.

    CALL METHOD o_textedit-&gt;get_text
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1.

    o_tab = lcl_app=&gt;exec_query(
              it_query = lt_query
              iv_upto  = lcl_app=&gt;default_rows
              ).

  ENDMETHOD.                    &quot;execute
  METHOD query_repo_init.

    DATA: lt_event TYPE cntl_simple_events,
          ls_event TYPE cntl_simple_event.

* Create a tree control
    CREATE OBJECT me-&gt;o_tree_qrep
      EXPORTING
        parent              = w-o_container_qrep
        node_selection_mode = cl_gui_simple_tree=&gt;node_sel_mode_single
      EXCEPTIONS
        lifetime_error      = 1
        cntl_system_error   = 2
        create_error        = 3
        failed              = 4
        OTHERS              = 5.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE a000(tree_control_msg).
    ENDIF.

* Catch double clic to open query
    ls_event-eventid = cl_gui_simple_tree=&gt;eventid_node_double_click.
    ls_event-appl_event = abap_true. &quot; no PAI if event occurs
    APPEND ls_event TO lt_event.

* Catch context menu call
    ls_event-eventid = cl_gui_simple_tree=&gt;eventid_node_context_menu_req.
*    ls_event-appl_event = abap_true. &quot; no PAI if event occurs
    APPEND ls_event TO lt_event.

    CALL METHOD me-&gt;o_tree_qrep-&gt;set_registered_events
      EXPORTING
        events                    = lt_event
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE a000(tree_control_msg).
    ENDIF.

* Assign event handlers in the application class to each desired event
    SET HANDLER me-&gt;hnd_repo_dblclick
        FOR me-&gt;o_tree_qrep.
    SET HANDLER me-&gt;hnd_repo_context_menu
        FOR me-&gt;o_tree_qrep.
    SET HANDLER me-&gt;hnd_repo_context_menu_sel
        FOR me-&gt;o_tree_qrep.

*  PERFORM repo_fill.
    me-&gt;load_repo( ).
  ENDMETHOD.                    &quot;query_repo_init
  METHOD hnd_repo_dblclick.

    DATA:
      lt_query   TYPE string_table,
      lt_string  TYPE string_table.

    DATA:
      ls_ztquery    TYPE ztquery,
      ls_query      TYPE soli,
      ls_qrep_node  TYPE ty_qrep_node,
      ls_local_vers TYPE ty_local_vers.

    DATA:
      lv_string     TYPE string,

      lv_readmode   TYPE i  VALUE 0.

    READ TABLE me-&gt;t_node_qrep INTO ls_qrep_node
                               WITH KEY node_key = node_key.

    IF sy-subrc = 0
    AND ls_qrep_node-relatkey IS NOT INITIAL.

      IF ls_qrep_node-relatkey = &apos;LOCAL&apos;.

        READ TABLE me-&gt;t_local_vers INTO ls_local_vers WITH KEY node_key = ls_qrep_node-node_key.

        IF syst-subrc IS INITIAL.

          lv_string = ls_local_vers-query.
          SPLIT lv_string
             AT cl_abap_char_utilities=&gt;cr_lf
           INTO TABLE lt_string.

        ENDIF.
      ELSE.
        SELECT SINGLE *
               FROM ztquery
               INTO ls_ztquery
              WHERE queryid = ls_qrep_node-queryid.
        IF syst-subrc &lt;&gt; 0 .
          RETURN.
        ENDIF.

        SPLIT ls_ztquery-query
           AT cl_abap_char_utilities=&gt;cr_lf
           INTO TABLE lt_string.

        me-&gt;s_ztquery = ls_ztquery.

      ENDIF.

      me-&gt;o_textedit-&gt;set_text( EXPORTING table  = lt_string
                               EXCEPTIONS OTHERS = 0
                              ).

      IF ls_qrep_node-edit = abap_true.
        lv_readmode = 0.
        me-&gt;v_editable = abap_true.
      ELSE.
        lv_readmode = 1.
        me-&gt;v_editable = abap_false.
      ENDIF.

      me-&gt;o_textedit-&gt;set_readonly_mode( EXPORTING readonly_mode          = lv_readmode    &quot; read-only mode; eq 0: OFF ; ne 0: ON
                                        EXCEPTIONS OTHERS                 = 0
                                       ).

      w-o_toolbar-&gt;set_button_visible( EXPORTING visible = me-&gt;v_editable&quot;&apos;X&apos;    &quot; Show/Hide
                                                 fcode   = &apos;SET_FLD_IP&apos;    &quot; Function Code
                                      EXCEPTIONS OTHERS  = 1
                                      ).

      me-&gt;set_focus_on_editor( ).

    ENDIF.
  ENDMETHOD. &quot;hnd_repo_dblclick
  METHOD hnd_repo_context_menu_sel.
    DATA:
      ls_node_key TYPE tv_nodekey,
      lv_subrc    TYPE i,
      ls_local    TYPE ty_qrep_node,
      lv_queryid  TYPE guid_32.

* Delete stored query
    CASE fcode.
      WHEN &apos;DELETE_QUERY&apos;.
        me-&gt;o_tree_qrep-&gt;get_selected_node( IMPORTING node_key = ls_node_key
                                          ).
*        PERFORM repo_delete_history USING l_node_key
*                                    CHANGING l_subrc.
*        IF lv_subrc = 0.
*          MESSAGE &apos;Query deleted&apos;(m02) TYPE c_msg_success.
*        ELSE.
*          MESSAGE &apos;Error when deleting the query&apos;(m03)
*                  TYPE c_msg_success DISPLAY LIKE c_msg_error.
*          RETURN.
*        ENDIF.

      WHEN &apos;DELETE_LOCAL&apos;.
*        CONCATENATE sy-uname &apos;+++&apos; INTO lw_queryid.
*        LOOP AT t_node_repository INTO ls_histo
*                WHERE queryid CP lw_queryid.
*          PERFORM repo_delete_history USING ls_histo-node_key
*                                      CHANGING l_subrc.
*          IF l_subrc NE 0.
*            MESSAGE &apos;Error when deleting the query&apos;(m03)
*                    TYPE c_msg_success DISPLAY LIKE c_msg_error.
*            RETURN.
*          ENDIF.
*        ENDLOOP.
*        MESSAGE &apos;All history entries deleted&apos;(m37) TYPE c_msg_success.
    ENDCASE.
  ENDMETHOD.                    &quot;hnd_repo_context_menu_sel
  METHOD hnd_repo_context_menu.
    DATA:
      ls_node_key TYPE tv_nodekey,
      ls_node_qrep TYPE ty_qrep_node.

    CALL METHOD me-&gt;o_tree_qrep-&gt;get_selected_node
      IMPORTING
        node_key = ls_node_key.
* For History node, add a &quot;delete all&quot; entry
* Only if there is at least 1 history entry
    IF ls_node_key = &apos;LOCAL&apos;.

      READ TABLE me-&gt;t_node_qrep TRANSPORTING NO FIELDS
                                 WITH KEY relatkey = &apos;LOCAL&apos;.
      IF sy-subrc = 0.

        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Delete All&apos;(m36)
            icon  = &apos;@02@&apos;
            fcode = &apos;DELETE_LOCAL&apos;.

      ENDIF.

      RETURN.

    ENDIF.

* Add Delete option only for own queries
    READ TABLE me-&gt;t_node_qrep INTO ls_node_qrep
               WITH KEY node_key = ls_node_key.
    IF sy-subrc &lt;&gt; 0
    OR ls_node_qrep-edit = space.
      RETURN.
    ENDIF.

    CALL METHOD menu-&gt;add_function
      EXPORTING
        text  = &apos;Delete&apos;(m01)
        icon  = &apos;@02@&apos;
        fcode = &apos;DELETE_QUERY&apos;.
  ENDMETHOD.                    &quot;hnd_repo_context_menu
  METHOD load_repo.
    DATA:
      ls_node_qrep TYPE ty_qrep_node.
    DATA:
      ls_local_vers TYPE ty_local_vers.
    DATA:
      lt_ztquery TYPE STANDARD TABLE OF ztquery,
      ls_ztquery TYPE ztquery.
    DATA:
      lv_xuclass TYPE xuclass.

    SELECT *
           FROM ztquery
           INTO TABLE lt_ztquery.

    IF syst-subrc IS NOT INITIAL.
*      RETURN.
    ENDIF.

    SELECT SINGLE class
           FROM usr02
           INTO lv_xuclass
           WHERE bname = syst-uname.

    REFRESH t_node_qrep.

    CALL METHOD me-&gt;o_tree_qrep-&gt;delete_all_nodes.

* Setup Private QUeries.
    CLEAR ls_node_qrep.
    ls_node_qrep-node_key = &apos;ME&apos;.
    ls_node_qrep-isfolder = abap_true.
    ls_node_qrep-text = &apos;My Private queries&apos;.
    ls_node_qrep-n_image = &apos;@VQ@&apos;.
    ls_node_qrep-exp_image = &apos;@VP@&apos;.
    APPEND ls_node_qrep TO t_node_qrep.

* Setup User&apos;s Shared QUeries.
    CLEAR ls_node_qrep.
    ls_node_qrep-node_key = &apos;ME_SHARED&apos;.
    ls_node_qrep-isfolder = abap_true.
    ls_node_qrep-text = &apos;My Shared queries&apos;.
    ls_node_qrep-n_image = &apos;@VQ@&apos;.
    ls_node_qrep-exp_image = &apos;@VP@&apos;.
    APPEND ls_node_qrep TO t_node_qrep.

* Setup SHared to User QUeries.
    CLEAR ls_node_qrep.
    ls_node_qrep-node_key = &apos;SHARED_ME&apos;.
    ls_node_qrep-isfolder = abap_true.
    ls_node_qrep-text = &apos;Shared to Me Queries&apos;.
    ls_node_qrep-n_image = &apos;@VQ@&apos;.
    ls_node_qrep-exp_image = &apos;@VP@&apos;.
    APPEND ls_node_qrep TO t_node_qrep.

* * Setup Un Saved Private QUeries.
    CLEAR ls_node_qrep.
    ls_node_qrep-node_key = &apos;LOCAL&apos;.
    ls_node_qrep-isfolder = abap_true.
    ls_node_qrep-text = &apos;Unsaved Query Versions&apos;.
    ls_node_qrep-n_image = &apos;@VQ@&apos;.
    ls_node_qrep-exp_image = &apos;@VP@&apos;.
    APPEND ls_node_qrep TO t_node_qrep.

    LOOP AT me-&gt;t_local_vers INTO ls_local_vers.
      CLEAR ls_node_qrep.
      ls_node_qrep-node_key = ls_local_vers-node_key.
      ls_node_qrep-relatkey = &apos;LOCAL&apos;.
      ls_node_qrep-relatship = cl_gui_simple_tree=&gt;relat_last_child.
      ls_node_qrep-n_image = ls_node_qrep-exp_image = &apos;@JO@&apos;.&quot;&apos;@K8@&apos;.
      ls_node_qrep-text = ls_local_vers-txt.
      ls_node_qrep-edit = abap_true.
      APPEND ls_node_qrep TO t_node_qrep.
    ENDLOOP.

    LOOP AT lt_ztquery INTO ls_ztquery.
      me-&gt;v_qrep_num = me-&gt;v_qrep_num + 1.
      CLEAR ls_node_qrep.

      ls_node_qrep-node_key = me-&gt;v_qrep_num.
      ls_node_qrep-relatship = cl_gui_simple_tree=&gt;relat_last_child.
      ls_node_qrep-isfolder = abap_false.
      ls_node_qrep-text = ls_ztquery-text.
      ls_node_qrep-queryid = ls_ztquery-queryid.

      IF ls_ztquery-owner = syst-uname.
        ls_node_qrep-edit = abap_true.
        IF ls_ztquery-visibility = &apos;0&apos;.
          ls_node_qrep-relatkey = &apos;ME&apos;.
          ls_node_qrep-n_image = ls_node_qrep-exp_image = &apos;@EK@&apos;.&quot;&apos;@K8@&apos;.
        ELSE.
          ls_node_qrep-relatkey = &apos;ME_SHARED&apos;.
          ls_node_qrep-n_image = ls_node_qrep-exp_image = &apos;@K8@&apos;.&quot;&apos;@K8@&apos;.

        ENDIF.

        ls_node_qrep-edit = abap_true.
        APPEND ls_node_qrep TO t_node_qrep.

      ELSE.
        IF  ls_ztquery-visibility = &apos;1&apos;
        AND ls_ztquery-visibility_group CS lv_xuclass
        OR ls_ztquery-visibility_users CS syst-uname .
          ls_node_qrep-relatkey = &apos;SHARED_ME&apos;.
          ls_node_qrep-n_image = ls_node_qrep-exp_image = &apos;@K8@&apos;.&quot;&apos;@K8@&apos;.
          APPEND ls_node_qrep TO t_node_qrep.
        ENDIF.
      ENDIF.

    ENDLOOP.

    me-&gt;o_tree_qrep-&gt;add_nodes(
      EXPORTING
        table_structure_name           = &apos;MTREESNODE&apos;
        node_table                     = t_node_qrep
      EXCEPTIONS
        OTHERS                         = 5
      ).

    IF sy-subrc &lt;&gt; 0.
      MESSAGE a000(tree_control_msg).
    ENDIF.

  ENDMETHOD.                    &quot;load_repo
  METHOD add_repo_local.

    DATA:
      ls_node_qrep TYPE ty_qrep_node,
      lt_node_qrep TYPE tty_qrep_node.
    DATA:
          ls_local_vers TYPE ty_local_vers.
    DATA:
          lt_query TYPE soli_tab.

    me-&gt;o_textedit-&gt;get_text( IMPORTING table                  = lt_query    &quot; document text
                             EXCEPTIONS OTHERS                 = 1
      ).

    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    ls_local_vers-node_key = lines( me-&gt;t_local_vers ) + 1.
    ls_local_vers-txt      = |Saved at { syst-datum } { syst-uzeit }|.
    ls_local_vers-query    = lcl_app=&gt;qtab_to_string( it_query =  lt_query iv_sep = cl_abap_char_utilities=&gt;cr_lf ).

    APPEND ls_local_vers TO me-&gt;t_local_vers.

    ls_node_qrep-node_key  = ls_local_vers-node_key.
    ls_node_qrep-relatkey  = &apos;LOCAL&apos;.
    ls_node_qrep-relatship = cl_gui_simple_tree=&gt;relat_last_child.
    ls_node_qrep-n_image   = ls_node_qrep-exp_image = &apos;@JO@&apos;.
    ls_node_qrep-text      = ls_local_vers-txt.
    ls_node_qrep-edit      = abap_true.

    APPEND ls_node_qrep TO lt_node_qrep.

    APPEND ls_node_qrep TO me-&gt;t_node_qrep.

*    me-&gt;o_tree_qrep-&gt;add_nodes(
*      EXPORTING
*        table_structure_name           = &apos;MTREESNODE&apos;
*        node_table                     = lt_node_qrep
*      EXCEPTIONS
*        OTHERS                         = 1
*      ).
*
*    IF sy-subrc &lt;&gt; 0.
*      MESSAGE a000(tree_control_msg).
*    ENDIF.
    me-&gt;load_repo( ).

    me-&gt;o_tree_qrep-&gt;set_selected_node(
      EXPORTING
        node_key = ls_node_qrep-node_key
      ) .


  ENDMETHOD.                    &quot;add_repo_local
  METHOD ddic_init.

    DATA:
      lv_mode     TYPE i.

    DATA:
      lt_events   TYPE cntl_simple_events.

    DATA :
      ls_header   TYPE treev_hhdr,
      ls_event    TYPE cntl_simple_event.

    DATA:
      lo_dragdrop TYPE REF TO cl_dragdrop.

    CHECK w-o_container_ddic IS NOT INITIAL.

    ls_header-heading = &apos;SAP Table/Fields&apos;.
    ls_header-width   = 30.

    lv_mode = cl_gui_column_tree=&gt;node_sel_mode_multiple.

    CREATE OBJECT me-&gt;o_tree_ddic
      EXPORTING
        parent                      = w-o_container_ddic
        node_selection_mode         = lv_mode
        item_selection              = abap_true
        hierarchy_column_name       = &apos;col1&apos;
        hierarchy_header            = ls_header
      EXCEPTIONS
        cntl_system_error           = 1
        create_error                = 2
        failed                      = 3
        illegal_node_selection_mode = 4
        illegal_column_name         = 5
        lifetime_error              = 6.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE a000(tree_control_msg).
    ENDIF.

* Co  lumn2
    me-&gt;o_tree_ddic-&gt;add_column(
      EXPORTING
        name                         = &apos;col2&apos;
        width                        = 41
        header_text                  = &apos;Description&apos;
      EXCEPTIONS
        column_exists                = 1
        illegal_column_name          = 2
        too_many_columns             = 3
        illegal_alignment            = 4
        different_column_types       = 5
        cntl_system_error            = 6
        failed                       = 7
        predecessor_column_not_found = 8
      ).

* Ma  nage Item clic event to copy value in clipboard
    ls_event-eventid    = cl_gui_column_tree=&gt;eventid_item_double_click.
    ls_event-appl_event = abap_true.
    APPEND ls_event TO lt_events.

    me-&gt;o_tree_ddic-&gt;set_registered_events(
      EXPORTING
        events                    = lt_events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3
      ).

    IF sy-subrc &lt;&gt; 0.
      MESSAGE a000(tree_control_msg).
    ENDIF.

* Ma  nage Drag from DDIC editor
    CREATE OBJECT lo_dragdrop.

    lo_dragdrop-&gt;add(
      flavor     = &apos;EDIT_INSERT&apos;
      dragsrc    = abap_true
      droptarget = space
      effect     = cl_dragdrop=&gt;copy
      ).

    lo_dragdrop-&gt;get_handle(
      IMPORTING
        handle = me-&gt;v_ddrop_hndl_tree
      ).

    SET HANDLER me-&gt;hnd_ddic_item_dblclick
            FOR me-&gt;o_tree_ddic.

    SET HANDLER me-&gt;hnd_ddic_drag
            FOR me-&gt;o_tree_ddic.

  ENDMETHOD.                    &quot;ddic_init
  METHOD is_tab_current_ddic_itm.
    DATA:
      ls_node_ddic       TYPE treev_node.

    LOOP AT me-&gt;t_node_ddic INTO ls_node_ddic.

      READ TABLE t_item_ddic TRANSPORTING NO FIELDS WITH KEY
                                                    node_key = ls_node_ddic-node_key
                                                    text     = iv_tabname .

      CHECK syst-subrc IS INITIAL.

      rv_yes = abap_true.

      RETURN.

    ENDLOOP.

  ENDMETHOD.                    &quot;is_tab_current_ddic_itm

  METHOD handle_dtoolbar_add.
    DATA:
      lt_ddic_fields  TYPE STANDARD TABLE OF lcl_app=&gt;ty_ddic_fields.

    DATA:
      lv_parent_node  TYPE tv_nodekey,
      lv_tabname      TYPE tabname.

    DATA:
      ls_node         TYPE treev_node,
      ls_item         TYPE mtreeitm,
      ls_ddic_fields  TYPE lcl_app=&gt;ty_ddic_fields.

    lv_tabname = to_upper( iv_val ).

    TRANSLATE lv_tabname USING &apos;. &apos;.

    TRY.
        lcl_app=&gt;chk_tabnm_empt_vald( lv_tabname ).

      CATCH lcl_error.    &quot;
        RETURN.
    ENDTRY.

    IF abap_true = me-&gt;is_tab_current_ddic_itm( lv_tabname ).
      RETURN.
    ENDIF.

    TRY.
        lcl_app=&gt;get_ddicfields(
          EXPORTING
            iv_val  = lv_tabname
          IMPORTING
            et_data = lt_ddic_fields
          ).

      CATCH lcl_error.
        RETURN.
    ENDTRY.

    CLEAR lv_tabname.
    SORT lt_ddic_fields BY position ASCENDING.

    LOOP AT lt_ddic_fields INTO ls_ddic_fields.

      IF lv_tabname &lt;&gt; ls_ddic_fields-tabname.

        me-&gt;add_new_ddic_tabfolder(
          ls_ddic_fields-tabname
          ).

        lv_parent_node = me-&gt;v_node_num.
        lv_tabname     = ls_ddic_fields-tabname.

      ENDIF.

      me-&gt;add_new_ddic_nodeitm(
        EXPORTING
          is_ddic_fields = ls_ddic_fields
          iv_parent_node = lv_parent_node
        ).

    ENDLOOP.

    me-&gt;rfrsh_ddic_tree( ).

  ENDMETHOD.                    &quot;handle_toolbar_add
  METHOD add_new_ddic_nodeitm.

    DATA:
      ls_node         TYPE treev_node,
      ls_item         TYPE mtreeitm.

    me-&gt;v_node_num      = me-&gt;v_node_num + 1.

    ls_node-node_key    = me-&gt;v_node_num.
    ls_node-relatkey    = iv_parent_node.
    ls_node-relatship   = cl_gui_column_tree=&gt;relat_last_child.

    IF is_ddic_fields-keyflag = space.
      ls_node-n_image   = &apos;@3W@&apos;.
      ls_node-exp_image = &apos;@3W@&apos;.
    ELSE.
      ls_node-n_image   = &apos;@3V@&apos;.
      ls_node-exp_image = &apos;@3V@&apos;.
    ENDIF.

    ls_node-dragdropid  = me-&gt;v_ddrop_hndl_tree.

    APPEND ls_node TO me-&gt;t_node_ddic.

    ls_item-node_key    = me-&gt;v_node_num.
    ls_item-class       = cl_gui_column_tree=&gt;item_class_text.
    ls_item-item_name   = &apos;col1&apos;.
    ls_item-text        = is_ddic_fields-fieldname.

    APPEND ls_item TO me-&gt;t_item_ddic.

    ls_item-item_name   = &apos;col2&apos;.

    IF is_ddic_fields-ddtext1 IS NOT INITIAL.
      ls_item-text      = is_ddic_fields-ddtext1.
    ELSE.
      ls_item-text      = is_ddic_fields-fieldname.
    ENDIF.

    APPEND ls_item TO me-&gt;t_item_ddic.

  ENDMETHOD.                    &quot;add_new_ddic_nodeitm

  METHOD add_new_ddic_tabfolder.
    DATA:
      ls_node         TYPE treev_node,
      ls_item         TYPE mtreeitm.

    me-&gt;v_node_num = me-&gt;v_node_num + 1.

    CLEAR ls_node.
    ls_node-node_key  = v_node_num.
    ls_node-isfolder  = abap_true.
    ls_node-n_image   = &apos;@PO@&apos;.
    ls_node-exp_image = &apos;@PO@&apos;.
    ls_node-expander  = abap_true.

    APPEND ls_node TO me-&gt;t_node_ddic.

    CLEAR ls_item.
    ls_item-node_key  = me-&gt;v_node_num.
    ls_item-class     = cl_gui_column_tree=&gt;item_class_text.
    ls_item-item_name = &apos;col1&apos;.
    ls_item-text      = iv_tabname.

    APPEND ls_item TO me-&gt;t_item_ddic.

    ls_item-item_name = &apos;col2&apos; .

    SELECT SINGLE ddtext
             INTO ls_item-text
             FROM dd02t
            WHERE tabname = iv_tabname
              AND ddlanguage = sy-langu
              AND as4local = &apos;A&apos;
              AND as4vers = space.

    IF sy-subrc NE 0.
      ls_item-text = iv_tabname.
    ENDIF.

    APPEND ls_item TO me-&gt;t_item_ddic.

  ENDMETHOD.                    &quot;add_new_ddic_tabfolder
  METHOD rfrsh_ddic_tree.

    CHECK me-&gt;t_item_ddic IS NOT INITIAL.

    me-&gt;o_tree_ddic-&gt;delete_all_nodes( ).

    o_tree_ddic-&gt;add_nodes_and_items(
      EXPORTING
        node_table                     = me-&gt;t_node_ddic
        item_table                     = me-&gt;t_item_ddic
        item_table_structure_name      = &apos;MTREEITM&apos;
      EXCEPTIONS
        failed                         = 1
        cntl_system_error              = 3
        error_in_tables                = 4
        dp_error                       = 5
        table_structure_name_not_found = 6
      ).

    IF sy-subrc &lt;&gt; 0.
*       handle Error later
    ENDIF.

    cl_gui_cfw=&gt;flush( ).
  ENDMETHOD.                    &quot;rfrsh_ddic_tree
  METHOD hnd_ddic_tbar_find.
    DATA :
      ls_item_ddic   TYPE mtreeitm,
      ls_sval        TYPE sval,
      ls_node_key    TYPE tv_nodekey   .

    DATA:
      lt_sval        TYPE ty_sval,
      lt_search      TYPE string_table,
      lt_nodekey     TYPE tv_nodekeys.

    DATA:
      lv_exit        TYPE abap_bool.

* Build search table

    CHECK me-&gt;t_item_ddic IS NOT INITIAL.

    LOOP AT me-&gt;t_item_ddic INTO ls_item_ddic.

      APPEND ls_item_ddic-text TO lt_search.
      APPEND ls_item_ddic-node_key TO lt_nodekey.

    ENDLOOP.

* As  k for selection search
    ls_sval-tabname   = &apos;RSDXX&apos;.
    ls_sval-fieldname = &apos;FINDSTR&apos;.
    ls_sval-value     = space.

    DO.

      me-&gt;itrative_ddic_srch(
        EXPORTING
          it_search   = lt_search
          it_node_key = lt_nodekey
        IMPORTING
          ev_exit     = lv_exit
        CHANGING
          cs_sval     = ls_sval
        ).

      CHECK lv_exit  = abap_true.

      EXIT.

    ENDDO.

  ENDMETHOD.                    &quot;hnd_ddic_tbar_find
  METHOD itrative_ddic_srch.

    DATA:
      lv_search      TYPE string,
      lv_search_term TYPE string,
      lv_search_line TYPE i.

    lcl_app=&gt;popup_get_values(
      IMPORTING
        ev_exit = ev_exit
      CHANGING
        cs_sval = cs_sval
      ).

    IF ev_exit = abap_true.

      ev_exit = abap_true.

      RETURN.

    ENDIF.
* For new search, start from line 1
    IF lv_search_term &lt;&gt; cs_sval-value.
      lv_search_term = cs_sval-value.
      lv_search_line = 1.
* For next result of same search, start from next line
    ELSE.
      lv_search_line = lv_search_line + 1 + lv_search_line MOD 2 .
    ENDIF.

    FIND FIRST OCCURRENCE OF cs_sval-value
                    IN TABLE it_search
                        FROM lv_search_line IN CHARACTER MODE IGNORING CASE
                  MATCH LINE lv_search_line.

    me-&gt;sel_node_post_srch(
      iv_ok        = syst-subrc
      iv_srch_line = lv_search_line
      it_node_key  = it_node_key  ).

  ENDMETHOD.                    &quot;itrative_ddic_srch

  METHOD sel_node_post_srch.
    DATA:
      ls_node_key    TYPE tv_nodekey .

    DATA:
      lt_nodesel     TYPE STANDARD TABLE OF tv_nodekey.

    DATA:
      lv_er_txt      TYPE string.

    IF iv_srch_line &lt;= 1.
      lv_er_txt = &apos;No Such Entry Exists.&apos;.
    ELSE.
      lv_er_txt = &apos;No Further Entries Found.&apos;.
    ENDIF.

    IF iv_ok = 0.

      READ TABLE it_node_key INTO ls_node_key INDEX iv_srch_line.

      IF syst-subrc IS INITIAL.

        APPEND ls_node_key TO lt_nodesel.

        me-&gt;o_tree_ddic-&gt;select_nodes(
          node_key_table = lt_nodesel
          ).

        me-&gt;o_tree_ddic-&gt;ensure_visible(
          node_key = ls_node_key
          ).

        RETURN.

      ENDIF.

    ENDIF.

    RAISE EXCEPTION TYPE lcl_error
      EXPORTING
        iv_text = lv_er_txt.

  ENDMETHOD.                    &quot;sel_node_post_Srch

  METHOD ddic_ret_selnode.

    DATA:
      ls_node_key    TYPE tv_nodekey.

*    Get Nodes
    me-&gt;o_tree_ddic-&gt;get_selected_nodes(
     CHANGING
       node_key_table   =   rt_node_key  &quot; Table with keys of selected nodes
     EXCEPTIONS
       OTHERS           = 5
     ).

    IF  sy-subrc = 0
    AND rt_node_key IS NOT INITIAL.

      RETURN.

    ENDIF.

*     Try to get Individual Node
    me-&gt;o_tree_ddic-&gt;get_selected_node(
      IMPORTING
        node_key    = ls_node_key   &quot; Key of Selected Node
      EXCEPTIONS
        OTHERS      = 4
      ).

    IF sy-subrc = 0
    AND ls_node_key IS NOT INITIAL.

      RETURN.

    ENDIF.

*     Last try, Get Selected Item
    me-&gt;o_tree_ddic-&gt;get_selected_item(
      IMPORTING
        node_key          = ls_node_key &quot; Node key
      EXCEPTIONS
        OTHERS            = 4
      ).

    IF sy-subrc &lt;&gt; 0
    OR ls_node_key IS INITIAL.

      RAISE EXCEPTION TYPE lcl_error
        EXPORTING
          iv_text = &apos;Could not find selected node&apos;.

    ENDIF.

    APPEND ls_node_key TO rt_node_key.


  ENDMETHOD.                    &quot;ddic_ret_selnode
  METHOD ddic_get_selfld.

    DATA:
      lt_node_key    TYPE treev_nks .

    DATA:
      ls_node_key    TYPE tv_nodekey,
      ls_node        TYPE treev_node,
      ls_item        TYPE mtreeitm,
      ls_item_parent TYPE mtreeitm,
      ls_fld         TYPE rsdsfields.

    REFRESH:
      et_fld[].

    lt_node_key = me-&gt;ddic_ret_selnode( ).

    LOOP AT lt_node_key INTO ls_node_key.

* Check clicked node is valid
      READ TABLE me-&gt;t_node_ddic INTO ls_node
                             WITH KEY node_key = ls_node_key.

      IF sy-subrc &lt;&gt; 0
      OR ls_node-isfolder = abap_true.

        RETURN.

      ENDIF.

* Get field name.
      READ TABLE me-&gt;t_item_ddic INTO ls_item
                             WITH KEY node_key  = ls_node_key
                                      item_name = &apos;col1&apos;.

      CHECK syst-subrc IS INITIAL.

* Get table name.
      READ TABLE me-&gt;t_item_ddic INTO ls_item_parent
                             WITH KEY node_key = ls_node-relatkey
                                      item_name = &apos;col1&apos;.

      CHECK syst-subrc IS INITIAL.

      ls_fld-tablename = ls_item_parent-text.
      ls_fld-fieldname = ls_item-text.

      APPEND ls_fld TO et_fld.

    ENDLOOP.

  ENDMETHOD.                    &quot;ddic_get_selfld

  METHOD hnd_ddic_inp.

    DATA:
      lt_where       TYPE rsds_twhere,
      lt_fld         TYPE rsdsfields_t,
      lt_query       TYPE soli_tab.

    me-&gt;ddic_get_selfld(
      IMPORTING
        et_fld = lt_fld
      ).

    IF lt_fld IS NOT INITIAL.

      lcl_app=&gt;call_sel_screen(
        IMPORTING
          et_where = lt_where
        CHANGING
          ct_fld   = lt_fld
        ).

      me-&gt;get_whr_4_inp(
        EXPORTING
          it_fld      = lt_fld
        IMPORTING
          et_query    = lt_query
        CHANGING
          rsds_twhere = lt_where
      ).

      me-&gt;set_txt_at_cursor(
        it_query = lt_query
        ).

    ENDIF.

  ENDMETHOD.                    &quot;hnd_ddic_inp
  METHOD get_whr_4_inp.

    DATA:
      ls_query   TYPE soli,
      ls_whr     TYPE rsds_where,
      ls_whrline TYPE rsdswhere.

    DATA:
      lv_join    TYPE abap_bool.

    me-&gt;o_textedit-&gt;get_text(
      IMPORTING
        table  = et_query[]
      EXCEPTIONS
        OTHERS = 1
      ).

    DELETE et_query WHERE line+0(1) = &apos;*&apos;.

    LOOP AT et_query INTO ls_query.

      CHECK ls_query-line CS &apos;JOIN&apos;.

      lv_join = abap_true.
      EXIT.

    ENDLOOP.

    REFRESH:
      et_query.

    lcl_app=&gt;ret_whr(
      EXPORTING
        iv_join  = lv_join
        it_fld   = it_fld
      CHANGING
        ct_whr   = rsds_twhere
      ).

    LOOP AT rsds_twhere INTO ls_whr.

      LOOP AT ls_whr-where_tab INTO ls_whrline.

        CONDENSE ls_whrline-line.

        APPEND ls_whrline-line TO et_query.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.                    &quot;get_whr_4_inp
  METHOD set_txt_at_cursor.
    DATA :
      lv_line_start  TYPE i,
      lv_pos_start   TYPE i,
      lv_line_end    TYPE i,
      lv_pos_end     TYPE i.

    me-&gt;o_textedit-&gt;get_selection_pos(
      IMPORTING
        from_line = lv_line_start
        from_pos  = lv_pos_start
        to_line   = lv_line_end
        to_pos    = lv_pos_end
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 4
      ).

    IF sy-subrc NE 0.
      MESSAGE &apos;Cannot get cursor position&apos; TYPE &apos;E&apos;.
    ENDIF.

*   If text is selected/highlighted, delete it
    IF lv_line_start NE lv_line_end
    OR lv_pos_start  NE lv_pos_end.

      me-&gt;o_textedit-&gt;delete_text(
        from_line = lv_line_start
        from_pos  = lv_pos_start
        to_line   = lv_line_end
        to_pos    = lv_pos_end
        ).

    ENDIF.

    me-&gt;set_txt_at_line(
        iv_line_start = lv_line_start
        iv_pos_start  = lv_pos_start
        iv_break      = lcl_app=&gt;paste_break
        it_query      = it_query
    ).



  ENDMETHOD.                    &quot;set_txt_at_cursor
  METHOD set_txt_at_line.
    DATA :
      lv_line_start  TYPE i,
      lv_pos_start   TYPE i.

    DATA:
      ls_query       TYPE soli.

    DATA:
      lt_query       TYPE soli_tab.

    lt_query[] = it_query[].

    IF iv_break = abap_true.
      APPEND &apos; &apos; TO lt_query.
    ENDIF.

    lv_line_start = iv_line_start.
    lv_pos_start  = iv_pos_start.

    me-&gt;o_textedit-&gt;insert_block_at_position(
      EXPORTING
        line     = iv_line_start
        pos      = iv_pos_start
        text_tab = lt_query[]
      EXCEPTIONS
        error_dp = 1
        OTHERS   = 2
      ).

    IF iv_break = abap_true.
      lv_line_start = lv_line_start + 1.
      lv_pos_start  = 1.
    ELSE.

      LOOP AT it_query INTO ls_query .
        lv_pos_start = lv_pos_start + strlen( ls_query ).
      ENDLOOP.

    ENDIF.

    me-&gt;o_textedit-&gt;set_selection_pos_in_line(
      EXPORTING
        line   = lv_line_start
        pos    = lv_pos_start
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2
      ).

* Focus on editor
    me-&gt;set_focus_on_editor( ).

  ENDMETHOD.                    &quot;set_txt_at_line
  METHOD hnd_ddic_toolbar_clic.

    DATA:
      lv_val   TYPE pvarfield.

    DATA:
      lo_error TYPE REF TO lcl_error.

    TRY.

        CASE fcode.

          WHEN &apos;ADD&apos;.

            lv_val = lcl_app=&gt;ret_tabname( ).

            IF lv_val IS NOT INITIAL.

              me-&gt;handle_dtoolbar_add( lv_val ).

            ENDIF.

          WHEN &apos;FIND&apos;.

            me-&gt;hnd_ddic_tbar_find( ).

          WHEN &apos;RFRS_DD_TRE&apos;.

            me-&gt;o_tree_ddic-&gt;delete_all_nodes( ).

            REFRESH:
              me-&gt;t_item_ddic,
              me-&gt;t_node_ddic.

            CLEAR:
              me-&gt;v_node_num.

          WHEN &apos;SET_FLD_IP&apos;.

            me-&gt;hnd_ddic_inp( ).

        ENDCASE.

      CATCH lcl_error INTO lo_error.

        MESSAGE s000(db) WITH lo_error-&gt;v_text DISPLAY LIKE &apos;E&apos;.

    ENDTRY.



  ENDMETHOD.                    &quot;hnd_ddic_toolbar_clic
ENDCLASS.                    &quot;lcl_app IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZQUERY_MAIN" VARCL="X" SUBC="I" APPL="W" LEVL="702" RSTAT="T" RMAND="101" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZRD_QUERY_MAIN" LENGTH="22 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZRD_QUERY_MAIN
*&amp;---------------------------------------------------------------------*
*----------------------------------------------------------------------*
*       CLASS lcl_main DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_main DEFINITION FINAL.

  PUBLIC SECTION.
    CLASS-DATA:
      o_self                        TYPE REF TO lcl_main READ-ONLY.
    CLASS-METHODS:
      init                          RAISING lcl_error,
      handle_initialization.
*      handle_start                  IMPORTING iv_query                     TYPE string
*                                              iv_upto                      TYPE i     .

    METHODS:
      handle_start                  IMPORTING iv_query                     TYPE string
                                              iv_upto                      TYPE i,
      handle_pbo                    IMPORTING iv_dynnr                     TYPE sydynnr,
      handle_pai                    IMPORTING iv_okcode                    TYPE okcode
                                    RETURNING VALUE(ro_ref_scr)            TYPE REF TO lcl_scr             .                                                  .

    .
  PRIVATE SECTION.
    DATA:
      o_ref_scr                     TYPE REF TO lcl_scr.
    METHODS:

      initiate_frontend_objects     RAISING lcl_error,
      init_custom_container         RAISING lcl_error.

ENDCLASS.  &quot;lcl_main

*----------------------------------------------------------------------*
*       CLASS lcl_main IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_main IMPLEMENTATION.
  METHOD init_custom_container.
  CREATE OBJECT w-o_container
    EXPORTING
      container_name = &apos;CUSTCONT&apos;
    EXCEPTIONS
      others         = 6.

  IF syst-subrc &lt;&gt; 0.

    RAISE EXCEPTION TYPE lcl_error
    EXPORTING iv_text = &apos;Error starting container.&apos;.

  ENDIF.
  ENDMETHOD.
  METHOD handle_pai.

  me-&gt;o_ref_scr =  me-&gt;o_ref_scr-&gt;handle_ucomm( iv_okcode ).

  ENDMETHOD.
  METHOD handle_pbo.

    me-&gt;o_ref_scr-&gt;handle_output( iv_dynnr ).

  ENDMETHOD.
  METHOD handle_start.

    IF  sy-batch IS NOT INITIAL
    AND iv_query  IS NOT INITIAL.

      lcl_app=&gt;handle_bg_alv( iv_query = iv_query
                              iv_upto  = iv_upto
                             ).

      RETURN.

    ENDIF.



    CALL SCREEN 8000.

  ENDMETHOD.                    &quot;handle_start
  METHOD handle_initialization .
    TRY.

        lcl_main=&gt;init( ).

        IF syst-batch IS INITIAL.

          lcl_main=&gt;o_self-&gt;initiate_frontend_objects( ).

        ENDIF.
      CATCH lcl_error.

        MESSAGE e000(db) WITH &apos;Error Initializing Components&apos;.

    ENDTRY.

  ENDMETHOD.                    &quot;handle_initialization
  METHOD init.

    CHECK lcl_main=&gt;o_self IS INITIAL.

      CREATE OBJECT lcl_main=&gt;o_self.

      IF lcl_main=&gt;o_self IS NOT BOUND.
        RAISE EXCEPTION TYPE lcl_error.
      ENDIF.

  ENDMETHOD.                    &quot;init
  METHOD initiate_frontend_objects.
    IF me-&gt;o_ref_scr IS INITIAL.
      me-&gt;init_custom_container( ).
      lcl_scr_static_objects_helper=&gt;init_screen_objects( W-o_container ).
      me-&gt;o_ref_scr = lcl_Scr=&gt;init_screen_objects( W-o_container ).

    ENDIF.


  ENDMETHOD.                    &quot;initiate_frontend_objects

ENDCLASS.                    &quot;lcl_main IMPLEMENTATION</source>
 </PROG>
 <TABL TABNAME="ZTQUERY" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Query Storage Database" AUTHCLASS="00" MAINFLAG="X" CONTFLAG="A" PROZPUFF="000" EXCLASS="4">
  <dd09l TABNAME="ZTQUERY" AS4LOCAL="A" AS4VERS="0000" TABKAT="1" TABART="APPL0" SCHFELDANZ="000" BUFALLOW="N"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="MANDT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000003" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="QUERYID" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="GUID_32" ADMINFIELD="0" INTTYPE="C" INTLEN="000032" NOTNULL="X" DOMNAME="SYSUUID_C" ROUTPUTLEN="000000" HEADLEN="07" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="GUID in &apos;CHAR&apos; Format in Uppercase" REPTEXT="GUID 16" SCRTEXT_S="GUID 16" SCRTEXT_M="GUID 16" SCRTEXT_L="GUID 16" DOMNAME3L="SYSUUID_C" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="OWNER" DDLANGUAGE="E" POSITION="0003" ROLLNAME="SYUNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000012" DOMNAME="SYCHAR12" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="User Name" REPTEXT="User" SCRTEXT_S="User" SCRTEXT_M="User Name" SCRTEXT_L="User Name" DOMNAME3L="SYCHAR12" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="TIMESTAMP" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TIMESTAMP" ADMINFIELD="0" INTTYPE="P" INTLEN="000008" DOMNAME="TZNTSTMPS" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000015" OUTPUTLEN="000019" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="UTC Time Stamp in Short Form (YYYYMMDDhhmmss)" REPTEXT="Time Stamp" SCRTEXT_S="Time Stamp" SCRTEXT_M="Time Stamp" SCRTEXT_L="Time Stamp" DOMMASTER="D" DOMNAME3L="TZNTSTMPS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="VISIBILITY" DDLANGUAGE="E" POSITION="0005" ROLLNAME="CHAR1" ADMINFIELD="0" INTTYPE="C" INTLEN="000001" DOMNAME="CHAR1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Single-Character Indicator" DOMNAME3L="CHAR1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="VISIBILITY_USERS" DDLANGUAGE="E" POSITION="0006" ADMINFIELD="0" INTTYPE="C" INTLEN="000400" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000400" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="VISIBILITY_GROUP" DDLANGUAGE="E" POSITION="0007" ROLLNAME="CHAR200" ADMINFIELD="0" INTTYPE="C" INTLEN="000200" DOMNAME="CHAR200" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000200" OUTPUTLEN="000200" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Text field length 200" REPTEXT="Text" SCRTEXT_S="Text (200)" SCRTEXT_M="Text (200 char)" SCRTEXT_L="Text (200 chars.)" DOMNAME3L="CHAR200" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="CHAR40" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="CHAR40" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Character field of length 40" REPTEXT="Char" SCRTEXT_S="Char" SCRTEXT_M="Char" SCRTEXT_L="Char" DOMNAME3L="CHAR40" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTQUERY" FIELDNAME="QUERY" DDLANGUAGE="E" POSITION="0009" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TRAN TCODE="ZQUERY" PGMNA="ZRD_QUERY" DYPNO="1000" CINFO="80">
  <tstct SPRSL="E" TCODE="ZQUERY" TTEXT="Query tcode"/>
  <tstcc TCODE="ZQUERY" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
</nugget>
